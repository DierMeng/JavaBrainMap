# MySQL 技能图谱概括版

## 数据库基础

### 概念

简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。所谓「数据库」系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。
### 模型

- 分类

	- 概念数据模型

		- 面向用户的，按照用户的观点进行建模，典型代表：E-R 图

	- 结构数据模型

		- 面向计算机系统的，用于 DBMS 的实现，典型代表有：层次模型，网状模型、关系模型、面向对象模型

- 三要素

	- 数据结构
	- 数据操作
	- 数据约束

- 概念数据模型

	- E-R 图（实体-联系图，Entity Relationship Diagram）

		- 实体、联系、属性
		- 一对一（1:1）、一对多（1:N）、多对多（M:N）
		- 既表示实体，也表示实体之间的联系，是现实世界的抽象，与计算机系统没有关系， 是可以被用户理解的数据描述方式。用户与系统设计者进行交流的工具
		- 实体用矩形框表示，联系用菱形表示，属性用椭圆表示

	- 示例（拉伸放大与缩小）

- 结构数据模型

	- 层次模型

		- 树形结构表示数据与数据之间的关系
		- 不能直接表示多对多的联系

	- 网状模型

		- 用网络结构表示数据与数据之间的联系的模型
		- 子节点和父节点联系不唯一，需要为联系命名
		- 更直观的描述世界，良好的性能，缺点是结构复杂

	- 关系模型

		- 采用表格结构表达实体集以及实体之间的联系，最大的特色就是描述的一致性。
		- 关系是一张表，关系数据模型由若干个表组成。
		- 可以存在1对1，1对多，多对多的关系

	- 面向对象模型

		- 指属性和操作属性的方法封装在称为对象类的结构中的模型。
		- 成分、概念

			- 对象
			- 类（对象类）
			- 类层次
			- 对象标识
			- 对象包含

### 常见数据库

- Oracle、DB2、SQL Server、PostgreSQL、MySQL、Sybase、Access、Informix、FoxPro、Redis、MongoDB

### 事务的基本概念

- 定义

	- 作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的一个逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

- ACID 原则

	- 原子性(Atomicity)

		- 事务中的所有元素作为一个整体提交或回滚，事务的个体元素是不可分的，事务是一个完整操作。

	- 一致性(Consistemcy)

		- 事务完成时，数据必须是一致的，也就是说，和事务开始之前，数据存储中的数据处于一致状态。保证数据的无损。

	- 隔离性(Isolation)

		- 对数据进行修改的多个事务是彼此隔离的。这表明事务必须是独立的，不应该以任何方式依赖于或影响其他事务。

	- 持久性(Durability)

		- 事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库。

### 数据库逻辑模式

- 基本概念定义

	- 数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。

		- 一个数据库只有一个模式
		- 是数据库数据在逻辑级上的视图
		- 数据库模式以某一种数据模型为基础
		- 定义模式时不仅要定义数据的逻辑结构，而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系

- 三级模式

	- 内模式

		- 也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式

			- 一个数据库只有一个内模式
			- 一个表可能由多个文件组成

				- 减少数据冗余，实现数据共享
				- 提高存取效率，改善性能。

	- 外模式

		- 也称子模式。或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。

			- 一个数据库可以有多个外模式
			- 外模式就是用户视图
			- 外模式是保证数据安全性的一个有力措施。

- 两级映射

	- 外模式-模式
	- 模式-内模式

## 数据库设计基础

### 设计规范

- 三范式

	- 第一范式（1NF）

		- 字段具有「原子性」 , 不可再分 。所有关系型数据库系统都满足第一范式。数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。

	- 第二范式（2NF）

		- 在第一范式的基础上建立起来的，满足第二范式必须先满足第一范式。要求数据库表中的每个实例或行必须可以被惟一地区分 。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键 。

	- 第三范式（3NF）

		-  必须先满足第二范式 。要求一个数据库表中不包含已在其它表中已包含的非主关键字信息
		- 特征

			- 每一列只有一个值
			- 每一行都能区分
			- 每一个表都不包含其他表已经包含的非主关键字信息

### 设计方法

- 设计目标

	- 满足应用功能
	- 良好的数据库性能

- 设计过程

	- 需求分析
	- 结构设计

		- 概念结构设计
		- 逻辑结构设计
		- 物理结构设计

	- 行为设计

		- 功能设计
		- 事务设计
		- 程序设计

	- 数据库实施

		- 加载数据库数据
		- 调试运行应用程序

	- 数据库运行和维护阶段

### 设计评审

## MySQL 基础知识

### 安装与配置

- Windows

	- 傻瓜式安装

- Linux

	- 安装 5.6

		- http://www.glorze.com/322.html

	- 安装 5.7

		- http://www.glorze.com/1412.html

- Mac

	- 傻瓜式安装

### 启动与关闭

- 主要体现在 Linux 中的一些命令，不同版本也有不同的实现，主要有 syetemctl start/stop mysql、service start/stop mysql 等

### 常用工具

- Navicat

	- http://www.glorze.com/320.html

- SqlYog

### 基本结构（SQL 的执行过程）

- 客户端

	- https://pic.imgdb.cn/item/5d89976a451253d178477d7b.png
MySQL 的 SQL 执行过程

- 连接器

	- 管理连接，权限验证

- 查询缓存

	- 命中则直接返回结果

- 分析器

	- 词法分析，语法分析

- 优化器

	- 执行计划生成，索引选择

- 执行器

	- 操作引擎，返回结果

- 存储引擎

	- 存储数据，提供读写接口

### 常用存储引擎

- MyISAM存储引擎（Full-text 索引，解决 like 查询低下）
- Innodb存储引擎（事务、外键）
- NDBCluster 存储引擎（分布式集群）
- Merge 存储引擎（为 MyISAM 提供统一接口）
- Memory 存储引擎（数据存储在内存中，不支持BLOB 和 TEXT）
- BDB 存储引擎（和 InnoDB 基本一样）
- FEDERATED 存储引擎（远程服务）
- BLACKHOLE 存储引擎（有去无回）
- CSV存储引擎（报表文件）

## MySQL开发基础

### SQL 语句

- 数据操纵语言

	- DDL（Data Definition Language），数据定义语言
	- DCL（Data Control Language），数据控制语言
	- DML（data manipulation language），数据操纵语言。

		- INSERT 插入、UPDATE 更新、DELETE 删除

	- DQL（Data Query Language），数据查询语言-select 关键字

- 同构/异构

	- 同构

		- 两个 SQL 语句可编译的部分是相同的，只是参数不一样而已
		- 在 JDBC 中，PreparedStatement 执行同构 SQL 语句的效率是比较高的，因为 PreparedStatement 对象一旦绑定了 SQL 语句，就只能执行这一条 SQL 语句

	- 异构

		- 两个 SQL 语句整个的格式都是不同的。 
		- Statement 则执行异构的 SQL 语句效率更高

- 各种关键字含义

	- EXIST、NOT EXIST

		- 带有 EXISTS 的子查询不返回任何数据，只产生逻辑真值「true」或者逻辑假值「false」。
		- 使用 NOT EXISTS 后，若对应查询结果为空，则外层的 WHERE 子语句返回值为真值，否则返回假值。

- SQL 语句函数

### CRUD

- 增加
- 查询
- 更新
- 删除

	- DELETE

		- delete 是 DML（数据操纵语言），执行 delete 操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在 redo 和 undo 表空间中以便进行回滚（rollback）和重做操作

			- 表空间要足够大，需要手动提交（commit）操作才能生效，可以通过 rollback 撤消操作。

		- delete 可根据条件删除表中满足条件的数据，如果不指定 where 子句，那么删除表中所有记录。 
		- delete 语句不影响表所占用的 extent，高水线（high watermark）保持原位置不变。

	- DROP

		- drop 是 DDL（数据定义语言），会隐式提交，所以，不能回滚，不会触发触发器。
		- drop 语句删除表结构及所有数据，并将表所占用的空间全部释放。
		- drop 语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。

	- TRUNCATE

		- truncate 是 DDL（数据定义语言），会隐式提交，所以，不能回滚，不会触发触发器。
		- truncate 会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到 minextents 个 extent，除非使用 reuse storage。
		- truncate 不会记录日志，所以执行速度很快，所以不能通过 rollback 撤消操作

			- 如果一不小心把一个表 truncate 掉，也是可以恢复的，只是不能通过 rollback 来恢复

		- 对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。
		- truncate table 不能用于参与了索引视图的表。
		- 在drop table的时候，innodb维护了一个全局锁，drop完毕锁就释放了。

	- 大表删除方案

		- Linux 硬链接

### 视图

### 存储过程

### 游标

### 触发器

### 事务

## MySQL 高级开发

### 事务

- 原子性（Atomic）

  事务中包含的操作被看作一个整体的业务单元，这个业务单元中的操作要么全部成功，要么全部失败，不会出现部分失败、部分成功的场景。
- 一致性（Consistency）

  事务在完成时，必须使所有的数据都保持一致状态，在数据库中所有的修改都基于事务，保证了数据的完整性。
- 隔离性（Isolation）

	- 隔离级别（当前读）

		- 未提交读（Read Uncommited）：脏读

			- 可以读取未提交记录。此隔离级别，不会使用，忽略。

		- 读写提交（Read Committed，RC）：幻读

			- 一个事务只能读取另外一个事务己经提交的数据，
不能读取未提交的数据。
			- 幻读的意思其实就是读写提交会产生不可重复读的问题

		- 可重复读（Repeatable Read，RR）

			- 字面的意思就是必须等上一个事务提交才能进行当前事务的读取操作，保证数据正确性。
			- RR 隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。


			- 在这里里面也有一个「幻读」的概念，不过可重复读产生幻读的现象不属于数据库存储的值，多半是统计值或者计算值。

		- 串行化（Serializable）

			- 从 MVCC 并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁，共享锁)，写加写锁 (X锁，排它锁)。
			- Serializable 隔离级别下，读写冲突，因此并发度急剧下降，在 MySQL/InnoDB 下不建议使用。

- 持久性（Durability）

  事务结束后，所有的数据会固化到一个地方，如保存到磁盘当中，即使断电重启后也可以提供给应用程序访问。
### 锁

- 锁

	- 共享锁
	- 排它锁
	- 乐观锁
	- 悲观锁
	- GAP 锁
	- 2PL（二阶段锁）：

		- 加锁阶段
		- 解锁阶段
		- 保证加锁阶段与解锁阶段不相交。

	- 死锁

	  死锁的发生与否，并不在于事务中有多少条 SQL 语句，死锁的关键在于：两个或以上的 Session 加锁的顺序不一致。
### 索引

- 索引（B+树）

  索引是一种数据结构，用于加快mysql获取数据的速度；
  
  常见索引模型：哈希表、有序数组、搜索树。
  
  索引类型：主键索引（存储整行数据）、非主键索引（主键的值，需要回表两次查询）
	- 数据结构角度

		- B+ 树索引（查询性能高、IO 次数少、范围查询简便）

			- 每一个父节点的元素都出现在子节点中，是子节点的最大或最小元素。
			- 非叶子节点不保存数据，只保存关键字用作索引，所有数据都保存在叶子节点中。
			- 内部节点不保存数据，所以能在内存中存放更多索引，增加缓存命中率。

		- 哈希索引（单行查询快）

		  哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
		  
		  作者：counterxing
		  链接：https://www.zhihu.com/question/67094336/answer/250034118
		  来源：知乎
		  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
			- 无法用于排序
			- 仅支持 < = > 以及 IN 操作
			- 哈希冲突比较多的话，维护代价高
			- 不能避免全表扫描
			- 不支持部分索引列匹配查找

		- FULLTEXT 全文索引（MyISAM 和 InnoDB）

			- 更建议使用 Lucene、Solar 等

		- R-Tree索引

			- 解决空间数据检索的问题。

	- 物理存储角度

		- 聚簇索引（Cluster Index）

			- InnoDB 存储引擎的数据组织方式就是聚簇索引表，完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。

		- 非聚簇索引

			- MyISAM 就是非聚簇索引
			- 叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

	- 逻辑角度

		- 主键索引，特殊的唯一索引，不允许为空，整行索引
		- 普通索引、单列索引
		- 多列索引、复合索引（遵循最左前缀原则）
		- 唯一索引或者非唯一索引
		- 空间索引（只存在 MYISAM 存储引擎中）

	- 设计索引的原则

		- 搜索的索引列，出现在 where 子句中的列
		- 使用唯一索引
		- 使用短索引，对字符串列进行索引，去字符串的前 N 个字符
		- 利用最左前缀，可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。
		- 不要过度索引，占磁盘空间，降低写操作性能。
		- InnoDB 尽量自己指定主键

	- 面试常问的「主键索引、唯一索引和普通索引的区别」

		- 主键索引

			- **主键索引只要搜索ID这个B+Tree即可拿到数据。**
			- **不允许空值**

		- 唯一索引

			- **必须唯一，允许空值**

		- 普通索引

			- **普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)**

			  回到主键索引树搜索的过程，称为回表
### SQL 模式

- SELECT @@GLOBAL.sql_mode;
- ANSI
- DB2
- MSSQL
- POSTGRESQL
- ORACLE
- MAXDB
- TRADITIONAL

### 分区表

- 分区类型

	- 水平分区

		- 将同一表中不同行的记录分配到不同的物理文件中；

	- 垂直分区

		- 将同一表中不同列的记录分配到不同的物理文件中；

- 分区表类型

	- 范围分区（RANGE）
	- 列表分区（LIST）
	- 哈希分区（HASH）
	- KEY 分区

- 分区管理

	- 增删改查

## MySQL 运维

### 日志

### 监控

### 备份与恢复

### 复制

## MySQL 优化

### 优化思路

- 自顶向下

	- 第一级别

		- 应用系统的 SQL 优化

			- 慢查询日志定位执行效率低的 SQL 语句
			- 用 explain 分析 SQL 的执行计划

	- 第二级别

		- MySQL 的服务器优化

	- 第三级别

		- 操作系统\硬件优化

	- 第四级别

		- 系统架构全局优化

			- 负载均衡
			- 缓存
			- 分布式
			- 读写分离
			- 主从

				- master 写入数据时会留下写入日志，slave 根据 master 留下的日志模仿其数据执行过程进行数据写入。
				- 主从不一致的诱因

					- mater 日志写入不成功导致 slave 不能正常模仿。
					- slave 根据 master 日志模仿时写入不成功。

				- 保证主从一致的方案

					- Master 角度

						- InnoDB Redo Log 记录了对数据文件的物理更改，并保证总是日志先行，在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。
						- Binlog和InnoDB Redo Log是否落盘将直接影响实例在异常宕机后数据能恢复到什么程度。
						- InnoDB 提供了相应的参数来控制事务提交时，写日志的方式和策略

							- innodb_support_xa=ON

								- 事务提交流程会变成两阶段提交，MySQL 内部 xa 事务

							- innodb_doublewrite=ON

								- 证不论是 MySQL Crash 还是 OS Crash 或者是主机断电重启都不会丢失数据

							- innodb_flush_log_at_trx_commit = 1
sync_binlog = 1

								- 保证每次事务提交后，都能实时刷新到磁盘中，尤其是确保每次事务对应的 binlog 都能及时刷新到磁盘中，只要有了 binlog，InnoDB 就有办法做数据恢复，不至于导致主从复制的数据丢失

					- slave 角度

						- 异步复制（不推荐）

							- 主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理

						- 半同步复制

							- 主库在应答客户端提交的事务前需要保证至少一个从库接收并写到 relay log 中
							- 存在数据丢失的问题

						- 全同步复制

							- 在调用 binlog sync 之后，engine 层 commit 之前等待 Slave ACK。这样只有在确认 Slave 收到事务 events 后，事务才会提交。

	- 垂直拆分
	- 水平拆分

- 软硬结合

	- SQL 语句以及索引优化
	- 表结构\表设计优化
	- 系统配置
	- 服务器硬件配置

### 慢 SQL 优化方案

- 慢 SQL 的因素

	- 索引设计问题
	- SQL 编写问题
	- 表结构（类型、长度等）设计问题
	- 锁
	- 并发对 IO/CPU 资源争用
	- 服务器硬件
	- MySQL 本身的 Bug

- 解决之道

	- 优化分析流程

		- 了解 SQL 的执行效率

			- show status like 'Com_%';  -- 了解 SQL 的执行频率
			- show status like 'Innodb_rows_%';

		- 定位慢查询

			- MyBatis 插件实现 SQL 监控
			- 通过慢查询日志定位那些执行效率较低的 SQL 语句

				- 打开慢查询

					- set global slow_query_log=on;

				- 查询 long_query_time 的值

					- show variables like 'long_query_time';  -- 慢查询阈值：默认为 10s

				- 查看慢查询日志路径

					- show variables like "slow_query_log%";

				- 注意：慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题时，查询慢查询日志并不能定位问题。

		- 连接数

			- 当数据库连接池被占满时，如果有新的 SQL 语句要执行，只能排队等待，等待连接池中的连接被释放。如果监控发现数据库连接池的使用率过高，甚至是经常出现排队的情况，则需要进行调优。

				- show variables like '%max_connection%'; -- 查看最大连接数
				- 在 /etc/my.cnf 里面设置数据库的最大连接数：max_connections = XXX
				- show status like  'Threads%'; -- 查看当前连接数

	- 执行计划（explain）详解

		- id

			- 执行编号，有几个 select 就有几个 id

		- select_type

			- 表示本行是简单的还是复杂的 select

				- simple

					- 简单查询，即查询不包含子查询和 union。

				- primary

					- 复杂查询中最外层的 select。

				- subquery

					- 包含在 select 中的子查询

				- derived

					- 包含在 from 子句中的子查询。MySQL 会将结果存放在一个临时表中，也称为派生表

				- union

					- 在 union 中的第二个和之后的 select 。

				- union result

					- 从 union 临时表检索结果的 select 。

				- dependent union

					- 首先需要满足 UNION 的条件及 UNION 中第二个以及后面的 SELECT 语句，同时该语句依赖外部的查询。

				- dependent subquery

					- 和 DEPENDENT UNION 相对 UNION 一样。

		- table

			- 正在访问哪一个表

		- type

			- 表示关联类型或访问类型，即 MySQL 决定如何查找表中的行

				- 结果值从好到坏依次是：NULL > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL。

					- NULL

						- MySQL 能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。

					- const、system

						- MySQL 能对查询的某部分进行优化并将其转化成一个常量，常用于 primary key 或 unique key 的所有列与常数比较时，因此表最多有一个匹配行，读取 1 次，速度比较快。


					- eq_ref

						- primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。

					- ref

						- 相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一索引的部分前缀。索引要和某个值相比较，可能会找到多个符合条件的行。

					- ref_or_null

						- 类似 ref，但是可以搜索值为 NULL 的行。

					- index_merge

						- 表示使用了索引合并的优化方法。

					- range

						- 范围扫描通常出现在 in()、between、>、<、>= 等操作中，表示使用一个索引来检索给定范围的行。一个良好的 SQL 效率至少要保证到该级别。

					- index

						- 和 ALL 一样，不同就是 MySQL 只需扫描索引树，这通常比 ALL 快一些。

					- ALL

						- 全表扫描，意味着 MySQL 需要从头到尾去查找所需要的行。

				- 一般来说，得保证查询至少达到 range 级别，最好能达到 ref 。

		- possible_keys

			- 哪些索引可以优化查询

		- key

			- 实际采用哪个索引来优化查询

				- 如果没有使用索引，则该列是 NULL。

		- key_len

			- 索引字段的长度

		- ref

			- 显示了之前的表在 key 列记录的索引中查找值所用的列或常量

		- rows

			- 为了找到所需的行而需要读取的行数

		- Extra

			- 执行情况的额外描述和说明

				- distinct

					- 一旦 MySQL 找到了与行相联合匹配的行，就不再搜索了。

				- Using index

					- 这发生在对表的请求列都是索引的时候，不需要读取数据文件，而从索引树（索引文件）中即可获得信息。这也是覆盖索引的标识，是性能高的表现。

						- 如果同时出现 using where，表明索引被用来执行索引键值的查找；
						- 没有 using where，表明索引用来读取数据而非执行查找动作。

				- Using where

					- 使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。
					- Extra 列出现 using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤，符合就留下，不符合就丢弃。

				- Using temporary

					- 表示需要用临时表保存中间结果，常用于 GROUP BY 和 ORDER BY 操作中，一般看到它说明查询需要优化了

				- Using filesort

					- MySQL需要额外的一次传递，以找出如何按排序顺序检索行。

				- Not exists

					- MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行，就不再搜索了。

				- Using index condition

					- 索引条件推送，MySQL 原来在索引上是不能执行如 like 这样的操作的，但是现在可以，这样少了不必要的 I/O 操作，但是只能用在二级索引上。

				- Using join buffer

					- 表示使用了连接缓存。

				- impossible where

					- 子句的值总是 false，不能用来获取任何元组。

				- select tables optimized away

					- 在没有 GROUP BY 子句的情况下，基于索引优化 MIN/MAX 操作
					- 对于 MyISAM 存储引擎优化 COUNT(*) 操作，而不必等到执行阶段再进行计算，即在查询执行计划生成的阶段就完成优化。

		- partitions(MySQL 8 新增)

			- 如果查询是基于分区表的话，会显示查询将访问的分区

		- filtered(MySQL 8 新增)

			- 按表条件过滤的行百分比。
			- rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数
			- 前一个表指 explain 中的 id 值比当前表 id 值小的表

	- 索引设计策略

		- 索引设计准则：三星索引

			- 第一颗星

				- 参与条件查询（where、join、order by、group by）的列可以组成单列索引或联合索引。

			- 第二颗星

				- 避免排序，如果 SQL 语句中出现 order by column，那么取出的结果集就应该已经是按照 column 排序好的，而不需要再进行排序生成临时表。

			- 第三颗星

				- SELECT 的列应尽量都是索引列，即尽量使用覆盖索引，避免回表查询。

	- SQL 优化

		- 开启查询缓存（MySQL 8.0 已废弃该功能）
		- 使用连接查询代替子查询
		- 当只要一行数据时使用 LIMIT 1
		- 多表关联查询时，小表在前，大表在后
		- 调整 where 子句中的连接顺序
		- 不要使用 ORDER BY RAND()
		- 优化 GROUP BY

			- GROUP BY … ORDER BY NULL;  -- 禁止排序

		- JOIN 查询

	- 表结构优化

		- 永远为每张表创建主键
		- 固定长度的表会更快
		- 通过拆分表，提高访问效率
		- 越小的列会越快
		- 使用 ENUM 而不是 VARCHAR

	- 事务和锁优化

		- 死锁调优

			- 排查死锁

				- 查看死锁日志：show engine innodb status;
				- 找出死锁 SQL
				- 分析 SQL 加锁情况
				- 模拟死锁案发
				- 分析死锁日志
				- 分析死锁结果

			- 如何减少死锁发生

				- 使用合适的索引。
				- 使用更小的事务。
				- 经常性的提交事务，避免事务被挂起。

		- 高并发事务调优

			- 结合业务场景，使用低级别事务隔离
			- 避免行锁升级表锁
			- 控制事务的大小，减少锁定的资源量和锁定时间长度

	- MySQL 服务端参数优化

		- Innodb_buffer_pool_size

			- 影响性能的最主要参数，一般建议配置为系统总内存的 70-80%，这个参数决定了服务可分配的最大内存。

		- Innodb_log_buffer_size

			- 用来设置 Innodb 的 Log Buffer 大小的，系统默认值为 1MB 。 Log Buffer 的主要作用就是缓冲 Log 数据，提高写 Log 的 I/O 性能。
			- 一般来说，如果你的系统不是写负载非常高且以大事务居多的话， 8MB 以内的大小就完全足够了。

		- 刷盘策略

			- Sync_binlog

				- 控制日志刷盘策略的，基于安全一般设置为 1。

			- Innodb_flush_log_at_trx_commit

				- 控制事务日志刷盘策略，基于安全一般设置为 1。

		- InnoDB 性能监控

			- create table innodb_monitor(a int) engine=innodb;  -- 持续获取状态信息的方法
			- 创建一个 innodb_monitor 空表后，InnoDB 会每隔 15 秒输出一次信息并记录到 Error Log 中。通过删除该表可停止监控。
			- 还可以通过相同的方式打开和关闭 innodb_tablespace_monitor、innodb_lock_monitor、innodb_table_monitor 这三种监控功能。

	- 硬件优化

		- CPU：多核高频
		- 内存：高内存
		- 磁盘：选择 SSD；且一般要求做 RAID

	- 架构优化

		- 主从复制&读写分离
		- 分库分表

