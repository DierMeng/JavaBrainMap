# RocketMQ

## 一、概念和特性

### 概念

- 消息模型（Message Model）

	- Producer

		- 负责生产消息

	- Broker

		- 负责存储消息
		- 实际部署过程中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker。

	- Consumer

		- 负责消费消息

	- ConsumerGroup

		- 由多个 Consumer 实例构成。

	- Message Queue

		- 用于存储消息的物理地址
		- 每个 Topic 中的消息地址存储于多个 Message Queue 中

- 消息生产者（Producer）

	- 负责生产消息，一般由业务系统负责生产消息。
	- 消息生产者会把业务应用系统里产生的消息发送到 broker 服务器。
	- 发送方式

		- 同步发送
		- 异步发送
		- 顺序发送
		- 单向发送

- 消息消费者（Consumer）

	- 负责消费消息，一般是后台系统负责异步消费。
	- 消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。
	- 消费形式

		- 拉取式消费
		- 推动式消费

- 主题（Topic）

	- 表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。

- 代理服务器（Broker Server）

	- 消息中转角色，负责存储消息、转发消息。
	- 代理服务器在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。
	- 代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。

- 名字服务（Name Server）

	- 名称服务充当路由消息的提供者。
	- 生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表。
	- 多个 Namesrv 实例组成集群，但相互独立，没有信息交换。

- 拉取式消费（Pull Consumer）

	- Consumer 消费的一种类型，应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。
	- 一旦获取了批量消息，应用就会启动消费过程。

- 推动式消费（Push Consumer）

	- Consumer 消费的一种类型，该模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。

- 生产者组（Producer Group）

	- 同一类 Producer 的集合，这类 Producer 发送同一类消息且发送逻辑一致。
	- 如果发送的是事务消息且原始生产者在发送之后崩溃，则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

- 消费者组（Consumer Group）

	- 同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。
	- 消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。
	- 消费者组的消费者实例必须订阅完全相同的 Topic。
	- 消息模式

		- 集群消费（Clustering）

			- 相同 Consumer Group 的每个 Consumer 实例平均分摊消息。
			- 一条消息只会被同 Group 中的一个 Consumer 消费
			- 多个 Group 同时消费一个 Topic 时，每个 Group 都会有一个 Consumer 消费到数据

		- 广播消费（Broadcasting）

			- 相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。
			- 消息将对一个 Consumer Group 下的各个  Consumer 实例都消费一遍

				- 即使这些 Consumer 属于同一个 Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。

- 普通顺序消息（Normal Ordered Message）

	- 消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。

- 严格顺序消息（Strictly Ordered Message）

	- 消费者收到的所有消息均是有顺序的。

- 消息（Message）

	- 消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。
	- RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key。
	- 系统提供了通过 Message ID 和 Key 查询消息的功能。

- 标签（Tag）

	- 为消息设置的标志，用于同一主题下区分不同类型的消息。
	- 来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。
	- 有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。
	- 消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。

### 特性

- 订阅与发布

	- 消息的发布是指某个生产者向某个 topic 发送消息；
	- 消息的订阅是指某个消费者关注了某个 topic 中带有某些 tag 的消息，进而从该 topic 消费数据。

- 消息顺序

	- 一类消息消费时，能按照发送的顺序来消费。
	- 顺序消息

		- 全局顺序消息

			- 某个 Topic 下的所有消息都要保证顺序；
			- 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。
			- 适用场景

				- 性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景

		- 分区顺序消息

			- 只要保证每一组消息被顺序消费即可。
			- 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。
			- Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。
			- 适用场景

				- 性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。

- 消息过滤

	- 消费者可以根据 Tag 进行消息过滤，也支持自定义属性过滤。
	- 在 Broker 端实现

		- 优点是减少了对于 Consumer 无用消息的网络传输
		- 缺点是增加了 Broker 的负担、而且实现相对复杂。

- 消息可靠性

	- 影响消息可靠性的几种情况

		- Broker 非正常关闭
		- Broker 异常 Crash
		- OS Crash
		- 机器掉电，但是能立即恢复供电情况
		- 机器无法开机
		- 磁盘设备损坏

- 至少一次

	- 每个消息必须投递一次。
	- Consumer 先 Pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会 ack 消息

- 回溯消费

	- 指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。

- 事务消息

	- 指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。
	- 提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。

- 定时消息

	- 指消息发送到 broker 后，不会立即被消费，等待特定时间投递给真正的 topic。
	- broker 有配置项 messageDelayLevel，是 broker 的属性，不属于某个 topic。
	- 发消息时，设置 delayLevel 等级即可

		- level == 0，消息为非延迟消息
		- 1<=level<=maxLevel，消息延迟特定时间，例如level==1，延迟1s
		- level > maxLevel，则level== maxLevel，例如level==20，延迟2h

- 消息重试

	- Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。
	- Consumer 消费消息失败的情况

		- 由于消息本身的原因，例如反序列化失败，消息数据本身无法处理
		- 由于依赖的下游应用服务不可用

- 消息重投

	- 生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway 没有任何保证。
	- 消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在 RocketMQ 中是无法避免的问题。

		- retryTimesWhenSendFailed

			- 同步发送失败重投次数，默认为 2

		- retryTimesWhenSendAsyncFailed

			- 异步发送失败重试次数，异步重试不会选择其他 broker，仅在同一个 broker 上做重试，不保证消息不丢。

		- retryAnotherBrokerWhenNotStoreOK

			- 消息刷盘（主或备）超时或slave不可用，是否尝试发送到其他broker，默认false。

	- 消息的重复消费

		- 原因

			- 正常情况下在消费者真正消费完消息后应该发送 ack，通知 broker 该消息已正常消费，从 queue 中剔除
			- 当 ack 因为网络原因无法发送到 broker，broker 会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到 consumer。
			- 在集群模式下，消息在 broker 中会保证相同 group 的 consumer 消费一次，但是针对不同 group 的 consumer 会推送多次

		- 解决方案

			- 数据库表

				- 处理消息前，使用消息主键在表中带有约束的字段中进行插入操作

			- 单机映射（Map）

				- 单机时可以使用 map 做限制，消费时查询当前消息 id 是不是已经存在

			- 集群分布式锁

- 流量控制

	- 生产者流控，因为broker处理能力达到瓶颈；
	- 消费者流控，因为消费能力达到瓶颈。

- 死信队列

	- 死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。
	- 存储死信消息的特殊队列称为死信队列

- 消息堆积

	- 添加消费者的数据量

### MQ 普遍作用

- 提升性能
- 系统解耦
- 流量消峰

## 二、架构设计

### Producer

- 消息发布的角色，支持分布式集群方式部署。
- Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。

### Consumer

- 消息消费的角色，支持分布式集群方式部署。
- 支持以 push 推，pull 拉两种模式对消息进行消费。
- 也支持集群方式和广播方式的消费，它提供实时消息订阅机制

### NameServer

- 是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper，支持 Broker 的动态注册与发现。
- 主要包括两个功能

	- Broker 管理

		- 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。
		- 提供心跳检测机制，检查 Broker 是否还存活；

	- 路由信息管理

		- 保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。

### BrokerServer

- 负责消息的存储、投递和查询以及服务高可用保证

	- Remoting Module

		- 整个 Broker 的实体，负责处理来自 clients 端的请求。

	- Client Manager

		- 负责管理客户端（Producer/Consumer）和维护 Consumer 的 Topic 订阅信息

	- Store Service

		- 提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能。

	- HA Service

		- 高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。

	- Index Service

		- 根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询。

- 任意一台 Broker 宕机

	- Broker 主从架构以及多副本策略
	- Master 收到消息后会同步给 Slave，这样一条消息就不止一份了，Master 宕机了还有 slave 中的消息可用，保证了 MQ 的可靠性和高可用性。

### https://pic.imgdb.cn/item/624d447f239250f7c57d0dd3.jpg
整体流程

- 启动 Namesrv，Namesrv起 来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。
- Broker 启动，跟所有的 Namesrv 保持长连接，定时发送心跳包。

	- 心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。
	- 注册成功后，Namesrv 集群中就有 Topic 跟 Broker 的映射关系。

- 收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在哪些 Broker上。也可以在发送消息时自动创建 Topic。
- Producer 发送消息

	- 启动时，先跟 Namesrv 集群中的其中一台建立长连接，并从Namesrv 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息。

- Consumer 消费消息

	- 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。

## 三、语义

### 消费语义

- 如何保证消息最多消费一次

	- 幂等性

- 如何保证消息至少消费一次

	- 消费者从 RocketMQ 拉取到消息之后，需要返回消费成功来表示业务方正常消费完成。

	  如果返回 CONSUME_LATER 则会按照不同的 messageDelayLevel 时间进行再次消费，时间分级从秒到小时，最长时间为2个小时后再次进行消费重试，如果消费满 16 次之后还是未能消费成功，则不再重试，会将消息发送到死信队列，从而保证消息存储的可靠性。
	  
	  
- 如何保证消息恰好消费一次

	- 幂等性

### 投递语义

- 如何保证消息最多投递一次
- 如何保证消息至少投递一次

	- producer 向 broker 发送消息后，没有收到 broker 的 ack 时，rocketmq 会自动重试。重试的次数可以设置，默认为 2 次

- 如何保证消息恰好投递一次

## 四、RocketMQ 如何保证消息不丢

### 生产者端

- 采取 send() 同步发消息，发送结果是同步感知的。发送失败后可以重试，设置重试次数。默认 3 次。

### Broker 队列存储端

- 修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。
- 集群部署
- 存储可靠性挑战

	- Broker正常关闭

		- Broker 可以正常启动并恢复所有数据

	- Broker异常Crash
	- OS Crash
	- 机器掉电，但是能立即恢复供电情况
	- 机器无法开机（可能是cpu、主板、内存等关键设备损坏）
	- 磁盘设备损坏

### 消费者端

- 完全消费正常后在进行手动 ack 确认

## 五、常用队列对比

### kafka

- Scala 开发
- 吞吐量所有 MQ 里最优秀，QPS 十万级、性能毫秒级、支持集群部署
- 功能单一
- 丢数据， 因为数据先写入磁盘缓冲区，未直接落盘。机器故障会造成数据丢失
- 适当丢失数据没有关系、吞吐量要求高、不需要太多的高级功能的场景,比如大数据场景

### RabbitMQ

- Erlang 开发
- 吞吐量比较低，QPS 几万级、性能 u 秒级、主从架构
- 功能单一
- Erlang 小众语言开发，吞吐量低，集群扩展麻烦
- 中小公司对并发和吞吐量要求不高的场景

### RocketMQ

-  java 开发
- 吞吐量高，QPS 十万级、性能毫秒级、支持集群部署
- 支持各种高级功能，比如延迟消息、事务消息、消息回溯、死信队列、消息积压等等
- 官方文档相对简单
- 适当丢失数据没有关系、吞吐量要求高、不需要太多的高级功能的场景

### ActiveMQ

- Java 开发，简单，稳定，性能不如前面三个

