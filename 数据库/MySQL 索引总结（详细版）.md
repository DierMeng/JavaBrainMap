# MySQL 索引总结（详细版）

## 一、索引的概念及作用

### 概念

- 索引是对数据库表中一列或多列的值进行排序的一种数据结构，好比是一本书前面的目录，可以增加对特定信息的查询速度。
- 索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的

	- 可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中

### 作用

- 索引能极大地减少扫描行数

	- 通过索引定位到要读取的页，大大减少了需要扫描的行数，能极大地提升效率。

- 索引可以帮助服务器避免排序和临时表

	- MySQL 的基本执行流程
（select * from user order by age desc;）

		- 扫描所有行，把所有行加载到内存后，按 age 排序生成一张临时表，再把这表结果返回给客户端。更糟的情况是，如果这张临时表的大小大于 tmp_table_size 的值（默认为 16 M），内存临时表会转为磁盘临时表，性能会更差。

	- 如果加了索引，因为索引本身是有序的，所以从磁盘读的行数据本身就是按 age 排序好的，也就不会生成临时表（空间消耗）和额外排序（CPU 消耗），所以提升了性能。

- 索引可以将随机 I/O 变成顺序 I/O

	- 磁盘的基础知识

		- 磁道

			- 扇区组成磁道，磁盘就是多个磁道组成

		- 扇区

			- 硬盘读写的基本单位，通常情况下每个扇区的大小是 512B。

		- 磁盘块

			- 操作系统（文件系统）读写数据的最小单位，相邻的扇区组合在一起形成一个块，一般是 4KB。

		- 页

			- 内存的最小存储单位，页的大小通常为磁盘块大小的 2^n 倍。

		- Seek Time（寻道时间）

			- 磁头移动到扇区所在的磁道。

		- Rotational Latency（旋转时延）

			- 磁头移动到同一磁道扇区对应的位置所需求时间。

		- Transfer Time（传输时间）

			- 从磁盘读取信息传入内存时间。

	- 如果信息在一个磁道中分散地分布在各个扇区中，或者分布在不同磁道的扇区上（寻道时间是随机 I/O 主要瓶颈所在），将会造成随机 I/O，影响性能。
	- MySQL 的数据是一行行存储在磁盘上的，并且这些数据并非物理连续地存储，这样的话要查找数据就无法避免随机在磁盘上读取和写入数据。
	- 当出现大量磁盘随机 I/O 时，大部分时间都被浪费到寻道上，随机 I/O 和顺序 I/O 大概相差百倍 

### 索引的缺点

- 索引需要占用物理空间，因此也增加了磁盘存储空间。
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还要保存或者更新对应的索引文件。
- 创建索引和维护索引要耗费空间和时间，这种耗费随着数据量的增加而增加，因此索引也不是越多越好，在数据量小的情况下则没必要建索引。

### 不适合建立索引的场景

- 数据量少
- 数据更新频繁
- 区分度低的字段（如性别、是否删除）

## 二、MySQL 存储引擎及对应索引

### InnoDB

- B+Tree
- B-Tree
- 哈希索引

	- 自适应哈希索引

### BDB

- 唯一哈希索引

### MyISAM

- R-Tree

### MEMORY

- 非唯一哈希索引（默认）
- B-Tree

### MERGE，也叫 MRG_MyISAM

### EXAMPLE

### NDB Cluster

### ARCHIVE

### CSV

### BLACKHOLE

### FEDERATED

### PERFORMANCE_SCHEMA

### TokuDB

### ScaleDB

## 三、MySQL 支持的索引类型

### B+树（B 代表的平衡树而不是二叉树，B+树索引并不是一颗二叉树）

- 支持的查询类型

	- 全关键字
	- 关键字范围
	- 关键字前缀

- 几种常用的使用场景

	- 全值匹配
	- 匹配值范围查询
	- 匹配最左前缀
	- 匹配列前缀
	- 精准或者匹配部分精准索引且匹配值范围查询匹配另外一列（覆盖索引）
	- 仅对索引进行查询匹配，即 select 索引列 from xx 这样的效率的更高
	- 匹配索引列为空一样会使用索引，类似于 「索引列 is null」的形式，优化器依然会进行索引优化查询
	- ICP 优化

		- 过滤操作下推操作，索引存在相关的列值，会直接在索引上进行条件过滤，然后回表查询，直接返回数据行指针，减少 I/O 操作。

- 缺点、限制，也算是几种索引失效的场景

	- 联合索引中如果不是按照索引的最左列开始查询，无法使用索引（col1,col2,col3），如果从 col2 或 col3 查询不会使用索引。
	- 联合索引中不能跳列查询，即必须满足最左原则。否则也不会使用索引。（col1,col2,col3），如果使用类似 col1=XX and col3=XX 查询不会使用索引。注意和上一条限制的区别。
	- 联合索引中如果某个列是范围查询，则后面的列索引失效。（col1,col2,col3）如果存在类似 col1=xx and col2 like ‘xx%’ and col3=xx，那么 col3 不会进行索引优化。
	- 以百分号「%」开头的 LIKE 查询不会使用 B-Tree 索引
	- 条件查询出现类型对应错误，会进行全表扫描，不会使用索引。例如：name=glorze，但是 name 是字符串类型，glorze 必须加引号。
	- 过滤性越高，MySQL 越容易使用索引。所以当 MySQL 认为全表扫描来得更快的时候不会使用索引。
	- 如果条件选择使用关键字「or」，即使前面的列有索引但是后面的列没有索引，涉及到的索引不会被使用。
	- 索引列是表达式或函数的一部分

		- 改造成基本字段区间的查找

	- 隐式类型转换
	- 隐式编码转换
	- 使用 order by 造成的全表扫描
	- like 通配符可能会导致索引失效
	- where 语句中包含 or 时，可能会导致索引失效

### HASH 哈希索引

- 只有 MEMORY 存储引擎显示支持
- 优点

	- 索引只需要存储哈希值，索引结构紧凑，查找速度非常快

- 缺点

	- 因为不存储字段值，所以无法避免要读取行
	- 因为哈希无序，所以无法排序
	- 联合索引中不支持部分列索引查询，只能捆在在一起使用
	- 不支持范围查询，只能用于等值查询
	- 哈希冲突的问题

### 全文索引

- 仅可用于 MyISAM 表， 主要用于在长篇文章中检索关键字信息。针对较大的数据，生成全文索引很耗时耗空间。

### R-Tree，空间数据索引

- MyISAM
- 地理数据存储

### 分形树索引

- TokuDB

## 四、索引的数据结构

### 索引解决的问题

- 等值查询
- 范围查询

### 哈希表

- 索引自身只存储对应的哈希值，索引的结构十分紧凑，所以哈希索引查找速度非常快
- 但是哈希索引不支持区间查找（需要挨个数据遍历，效率低），更多的时候哈希表是与 B+ 树等一起使用的。

	- InnoDB 引擎中就有一种名为「自适应哈希索引」的特殊索引

### B+ 树

- 二叉查找树（BST）

	- 综合了顺序表（查找效率高）和链表（增删效率高）优势的折中方案，每个节点最多有 2 个子节点，且左子树和右子树数据顺序是左小右大。
	- 为了保证每次查找都可以这折半而减少 I/O 次数，但是二叉树很考验第一个根节点的取值，因为很容易在这个特点下出现「树不分叉」的情况

- 平衡二叉查找树（AVL）

	- 采用二分法思维，平衡二叉查找树除了具备二叉查找树的特点，主要的特征是树的左右两个子树的层级最多相差 1。
	- 插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。
	- 缺点

		- 时间复杂度和树高相关

			- 树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。
			- 树的高度等于每次查询数据时磁盘 I/O 操作的次数。

		- 平衡二叉树不支持范围查询的快速查找

			- 范围查询时需要从根节点多次遍历，查询效率不高。

- B 树：改造二叉树，变为多叉平衡查找树

	- 特点

		- B 树的节点中存储着多个元素，每个节点有多个分叉。
		- 节点中的元素包含键值和数据，节点中的键值从大到小排列。所有的节点都储存数据。
		- 父节点当中的元素不会出现在子节点中。
		- 所有的叶子节点都位于同一层，且叶子节点之间没有指针连接。

	- 缺点

		- B 树也不支持范围查询的快速查找
		- 如果 data 存储的是行记录，行的大小随着列数的增多，所占空间会变大。

- B+ 树：改造 B 树（非叶子节点是否存储数据）

	- 只有叶子节点才会存储数据，非叶子节点至存储键值。
	- 叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

## 六、常用的索引设置策略，InnoDB 索引实现

### 避免几种索引失效的场景

### 独立的列

- 索引的列不能是表达式的一部分
- 不能是函数的参数

### 前缀（后缀）索引和索引选择性

- 索引选择性

	- 定义：不重复的索引值和表的总记录数的比例。所以比例越高，索引的性能的就越高。
	- 唯一索引的索引选择性是 1，所以相对来讲，唯一索引的性能是最好的

- 如果某一字段类似于 http 链接那样长且在生产情景下需要添加索引，那么就可以考虑前缀索引。这样既能保证索引的高性能，又能避免性能开销过大。但是要注意前缀索引的合适选取长度。
- 前缀索引的缺点

	- 无法进行排序 order by
	- 无法进行分组 group by
	- 无法进行覆盖扫描

### 复合索引，多列索引、组合索引

- 把 where 后面的常用列都建立单独索引其实不是一个优秀的解决方案。
- MySQL 中的有个「索引合并」的概念，对于多个单列索引进行的复杂查询会进行优化，从而也说明单列索引的性能在大多数时候失效
- 建立联合索引的时候需要考虑联合索引的合理顺序以及要注意联合索引的经常失效的场景。
- 合适的索引列顺序

	- 在不考虑排序和分组的情况下，如果用于优化 where 条件的查找，可以考虑将选择性最高的列放到索引最前列。

- 最左匹配原则，在遇到范围查询的时候，就会停止匹配。

### 聚簇索引

- 聚簇索引不是一种索引形式，而是一种数据存储形式，在 InnoDB 中，主键索引存储完整数据行，叶子节点存储的数据是整行记录
- 优点

	- 相关数据保存在一起，数据访问更快
	- 使用覆盖索引扫描的查询可以直接使用叶子节点的值

- 缺点

	- 虽然将数据放在内存中会是速度加快，但是也增加了存储开销，所以将数据全部放入内存也就意味着聚簇索引失去了意义
	- 插入速度依赖于插入顺序
	- 更新聚簇索引列的代价、开销会变得更高
	- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。

		- 平衡树的数据结构，如果插入不规则的数据，会导致当前节点所属的页满，然后进行页分裂操作，容纳新增的数据，这样的话会极大的影响性能。
		- 这也是建议 InnoDB 建议逐渐设置为自增的原因，而尽量不要使用 UUID 或者无规则的字符串作为主键。

	- 可能导致全表扫描变慢，尤其是行比较稀疏或者存储不连续

### 覆盖索引（只有 B+树支持）

- 索引包含所有需要查询的字段的值，就称之为「覆盖索引」
- 优点

	- 不需要回表查询，减少数据访问量。
	- 简单的范围查询可以使用顺序的索引访问

### 使用索引扫描做排序

- 两种排序

	- order by 排序操作
	- 索引顺序扫描

- 在索引设计的时候需要设置某一索引，让其尽量既能满足手动排序，又能做查找，设计就算是比较好的。要求索引的列顺序和 order by 顺序一致。

### 避免冗余和重复索引

## 五、索引（B+树）

索引是一种数据结构，用于加快mysql获取数据的速度；

常见索引模型：哈希表、有序数组、搜索树。

索引类型：主键索引（存储整行数据）、非主键索引（主键的值，需要回表两次查询）
### 数据结构角度

- https://pic.imgdb.cn/item/624c5345239250f7c529594f.png
B+ 树索引（查询性能高、IO 次数少、范围查询简便）

	- 每一个父节点的元素都出现在子节点中，是子节点的最大或最小元素。
	- 非叶子节点不保存数据，只保存关键字用作索引，所有数据都保存在叶子节点中。
	- 内部节点不保存数据，所以能在内存中存放更多索引，增加缓存命中率。

- 哈希索引（单行查询快）

  哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
  
  作者：counterxing
  链接：https://www.zhihu.com/question/67094336/answer/250034118
  来源：知乎
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	- 无法用于排序
	- 仅支持 < = > 以及 IN 操作
	- 哈希冲突比较多的话，维护代价高
	- 不能避免全表扫描
	- 不支持部分索引列匹配查找

- FULLTEXT 全文索引（MyISAM 和 InnoDB）

	- 更建议使用 Lucene、Solar 等

- R-Tree索引

	- 解决空间数据检索的问题。

### 物理存储角度

- 聚簇索引（Cluster Index）

	- InnoDB 存储引擎的数据组织方式就是聚簇索引表，完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。

- 非聚簇索引

	- MyISAM 就是非聚簇索引
	- 叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### 逻辑角度

- 主键索引，特殊的唯一索引，不允许为 null，整行索引

	- 主键可作外键，唯一索引不可。

- 普通索引、单列索引、二级索引、辅助索引

	- 一个索引只包含单个列。一个表可以有多个单列索引，注意：单列索引不是组合索引。
	- 唯一任务是加快对数据的访问速度
	- 会回表查询：先搜索索引拿到主键值，再到主键索引树搜索一次
	- 叶子节点存储的数据是该行的主键值

- 多列索引、复合索引、联合索引（遵循最左前缀原则）

	- 一个索引包含多个列
	- 最左前缀原则

		- 当创建 (a,b,c) 联合索引时，相当于创建了 (a) 单列索引、(a,b) 联合索引以及 (a,b,c) 联合索引。
		- 要想索引生效的话，只能使用 a 和 a,b 和 a,b,c 这三种组合（a,c 组合也可以，但实际上只用到了 a 的单列索引，c 并没有用到）。

	- 创建联合索引时，应该仔细考虑列的顺序

- 唯一索引或者非唯一索引

	- 唯一索引索引列的值必须唯一，但允许有 NULL。
	- 唯一索引可以有多个，如果是组合索引，则列值的组合必须唯一。
	- 如果在一个列上同时建唯一索引和普通索引的话，Mysql 会自动选择唯一索引。
	- 唯一索引可以保证数据记录的唯一性。
	- 在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

- 空间索引（只存在 MYISAM 存储引擎中）

### 设计索引的原则

- 基本原则

	- 搜索的索引列，出现在 where 子句中的列
	- 使用唯一索引
	- 使用短索引，对字符串列进行索引，取字符串的前 N 个字符
	- 利用最左前缀，可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
	- 不要过度索引，占磁盘空间，降低写操作性能。
	- InnoDB 尽量自己指定主键

- 三星原则

	- 第一颗星

		- 参与条件查询（where、join、order by、group by）的列可以组成单列索引或联合索引。

	- 第二颗星

		- 避免排序，如果 SQL 语句中出现 order by column，那么取出的结果集就应该已经是按照 column 排序好的，而不需要再进行排序生成临时表。

	- 第三颗星

		- SELECT 的列应尽量都是索引列，即尽量使用覆盖索引，避免回表查询。

