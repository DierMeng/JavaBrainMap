# JVM 杂记

## 类的加载

### 类的加载、连接、初始化

- 加载

  通过一个类的名字获取此类的二进制字节流，将这个字节流代表的静态存储结构转换为方法区的运行时结构，在内存中生成一个 java.lang.Class 对象，作为方法区这个类的各种数据结构的访问入口。

- 连接

	- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
	- 准备：类准备阶段负责为类的类变量分配内存，并设置默认初始值。
	- 解析：将类的二进制数据中的符号引用替换成直接引用。

- 初始化：对类变量、静态初始块、类的结构块等进行初始化

  一、加入这个类还没有被加载和连接，则程序先加载并连接该类。
  二、假如该类的直接父类还没有被初始化，则先初始化其直接父类，依次往上进行初始化，所以 JVM 最先初始化的总是 java.lang.Object 类。
  三、假如类中有初始化语句,则系统一次执行这些初始化语句

### 类加载器

- new 一个 Object 在内存中占多大？

	- 至少 16 个字节，对象头 Markword 占 8 字节（cafe babe、jdk 版本号），引用类型在 64 位机器上占 4 个字节（不开启指针压缩是8个字节，指针压缩是默认开启的），对齐填充 4 字节，所以至少 16 字节

- 双亲委派的优势

	- 保证 JVM 运行环境中只有一份字节码文件，即保证不会重复加载一个类。
	- 增加程序的安全性，即黑客无法通过重写已经有的类，进行攻击。
	- JAVA 的类随着它的类加载器一起具备了带有优先级的层级关系。

- 对象创建过程

	- 流程：类加载、内存分配、初始化、设置对象头、INIT方法(构造函数)

		- 类加载，需要遇到关键字 new 触发。当虚拟机遇到该关键字的时候，定位到方法区中的常量池，在常量池中寻找 new 对应类的符号引用，并检查该符号引用对应的类是否被类加载系统加载。加载成功进行内存分配，否则继续加载。
		- 内存分配，即 JVM 在堆中进行对象内存分配，对象所需要的内存大小，在类加载过程中就已确定。
		- 初始化，即将内存空间初始化为默认值，包括对象字段。
		- 设置对象头

			- 存储对象自身运行时的数据，hashCode 码、GC 分代年龄、锁状态标志、线程持有的锁。
			- 类型指针，即对象指向它的元数据的指针，JVM 通过该指针确定这个对象是哪个类的实例。

		- 执行 INIT 方法，即构造函数。

### 自定义类加载器

- 无法自定义一个叫 java.lang.System 的类

	- 会调用自定义类加载器的 loadClass 方法。
	- 我们自定义的 classLoader 必须继承 ClassLoader,loadClass 方法会调用父类的 defineClass 方法。
	- 父类的这个 defineClass 是一个 final 方法,无法被重写
	- 所以自定义的 classLoader 是无论如何也不可能加载到以 java. 开头的类的。

### JVM 进程终止

- 程序运行正常结束
- System.exit() 或者 Runtime.getRuntime().exit()
- 异常未捕获或者 error
- 强制结束 JVM 进程或者 JVM 自身故障

	- JVM 发生致命错误导致崩溃时，会生成一个 hs_err_pid_xxx.log
	- 文件包含了导致 JVM crash 的重要信息，生成在工作目录下，也可以通过 JVM 参数指定生成路径

- linux 的 OOM killer 杀死

	- Linux 内核有个机制叫OOM killer，会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。
	- 系统报错日志

		- /var/log/messages
		- egrep -i 'killed process' /var/log/messages
		- dmesg | grep java

- JVM 报 OOM 异常

	- -XX:+HeapDumpOnOutOfMemoryError
	- -XX:HeapDumpPath=*/java.hprof

### 区别

- Class.forName

	- 加载类是将类进了初始化
	- 相当于调用无参构造函数，会调用 static 静态代码来初始化配置

- ClassLoader.getSystemClassLoader().loadClass

	- 没有对类进行初始化，只是把类加载到了虚拟机中
	- IOC 的实现就是使用的 ClassLoader

## JVM 内存模型

### JVM 内存区域划分、Java 运行时数据区

- 方法区（Method Area）

	- 运行时常量
	- 已被虚拟机加载的类信息
	- 静态变量
	- 即时编译器编译后的代码
	- 运行时常量池

- 堆（Heap）

	- 存放对象实例
	- 对象的创建

		- new 一个对象后，jvm 会先检查类是否已被加载，若未加载则先加载 ，否则在堆区创建该对象。
		- 对象在堆区的存储结构

			- 对象头

				- MarkWord

					- hashcode、gc 对象年龄、锁信息

				- Class Metadata Address

					- 指向对象类型数据的指针

				- Array Length

					- 数组长度

			- 实例数据
			- 填充数据

- 虚拟机栈（VM Stack）

	- 每个方法执行的同时都会创建一个栈帧，局部变量表、操作数栈、动态连接、返回地址等。
	- 存储局部变量表(boolean、byte、char、short、int、float、long、double、对象引用、returnAddress)
	- 方法出口
	- 每个方法从调用直至执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。
	- 变量从产生到结束所经历的过程

		- 局部变量：局部变量随着方法的调用产生和结束，在调用方法的时候会创建栈帧，而栈帧里存在局部变量表，当方法调用结束的时候栈帧销毁，局部变量随着销毁。
		- 常量/静态变量：一般存放在元空间，而元空间的周期与堆相似，声明并赋值后直接放入常量池，之后通过可达性分析判断常量是否存在引用链，如不存在移除常量池。

- 本地方法栈（Native Method Stack）

	- 为虚拟机使用到的 Native 方法服务

- 程序计数器（Program Counter Register）

	- 唯一一个在 JVM 中没有规定任何 OutOfMemoryError 情况的区域
	- 通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线城恢复等基础功能都需要依赖程序计数器。

- 执行引擎
- 本地库接口
- 本地方法库

### JVM 内存模型

- Java 线程
- 工作内存
- Save 和 Load 操作
- 主内存
- voatile 关键字

	- 当这个变量的值被修改后，会立即刷新到主内存中，对其他线程可见；当某个线程读取这个变量的时候，也会重新将主内存中的数据刷一份到工作内存中来。保证可见性，但是不保证原子性
	- 禁止指令重排优化，也叫禁止指令重排序.观察voatile变量对应的字节码文件，会发现变量的操作指令后面加了一句lock addl $0x0,(%esp)的操作，这个操作相当于一个内存屏障。

- synchronized

	- 当一个线程对一个变量加锁的时候，就会清空这个变量在当前工作内存中的值，因此该关键字同时满足了可见性和原子性。

## 垃圾回收与内存分配

### 对象的存活

- 引用计数法，Java 虚拟机不采用

	- 基本定义：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
	- 弊端：很难解决对象之间相互循环引用的问题

	  对象 objA 和 objB 都有字段 instance，赋值令 objA.instance=objB 及 objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知GC收集器回收它们。

- 可达性分析法

	- 基本思路（图片可拖拽放大）

		- 是通过一系列的称为「GC Roots」的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（或者说从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

	- Java 可作为 GC Roots 的对象

		- 虚拟机栈（栈帧中的本地变量表）中引用的对象
		- 方法区中类静态属性引用的对象
		- 方法区中常量引用的对象
		- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

- 引用

	- 基本定义

		- 如果 reference 引用类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，但是我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。所以在 JDK 1.2 之后重新设计了引用的概念。

	- 分类

		- 强引用（Strong Reference）

			- 在程序代码之中普遍存在的，类似「Object obj=new Object()」这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

		- 软引用（Soft Reference）

			- 用来描述一些还有用但并非必需的对象。

			  对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2  之后，提供了 SoftReference 类来实现软引用。

		- 弱引用（Weak Reference）

			- 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。

		- 虚引用（Phantom Reference）

			- 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
			- 目的：在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。

- 无用的类的条件

	- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
	- 加载该类的 ClassLoader 已经被回收。
	- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 回收算法（heap，堆内存的回收）

- 标记-清除算法（Mark-Sweep）

	- 首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记的方式：可达性分析。
	- 最基础的收集算法，后续所有的算法在此基础上改进而来。
	- 缺点一：效率不高，标记和清除的效率都不高。
	- 缺点二：产生大量的不连续内存碎片，导致程序运行过程中如果分配较大对象时，无法找到足够连续内存而触发垃圾收集动作。

- 复制算法（Copying）

	- 将可用内存按容量划分为大小相等的两快，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收。
	- HotSpot 虚拟机将内存分为 1 个 Eden 和两个 Survivor 空间，比例 8:1 
	- 缺点：将内存玩的只剩下一半了，复制操作比较多，效率比较低。

- 标记-整理算法（Mark-Compact）

	- 就是标记之后不直接清除，而是让存活对象向一端移动，最后清理掉边界以外的内存。
	- 适合老年代使用

- 分代收集算法

	- 动态划分算法，根据对象的存活周期划分模块，根据对应的模块采取相应的回收算法。
	- 新生代：因为有大批量的对象死去，存活少量，所以一般采用复制回收算法。
	- 老年代：顾名思义就是对象寿命比较长，所以没有额外空间对其进行分配担保，一般采用「标记-清理」或者标记-整理算法
	- 永久代（Full GC）

		- 永久代是 Hotspot 虚拟机特有的概念，是方法区的一种实现，别的 JVM 都没有这个东西。在Java 8 中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存-元空间。 

### 垃圾收集器

- GC 流程

	- 当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；
	- 首先会判断 Eden 区是否有内存空间，如果此时有内存空间，则直接将新对象保存在 Eden 区
	- 但是如果此时 Eden 区的内存空间不足，那么会自动执行一个 MinorGC、Young GC 操作，将 Eden 区的无用内存空间进行清理，清理之后会继续判断 Eden 区的内存空间是否充足？如果内存空间充足，则将新的对象直接在 Eden 区进行空间分配
	- 如果执行了 Minor GC、Young GC 之后发现 Eden 区的内存依然不足，那么这个时候会进行 Survivor 区判断，如果 Survivor 区有剩余空间，则将 Eden 区的部分活跃对象保存在 Survivor ，那么随后继续判断 Eden 区的内存空间是否充足，如果充足，则在 Eden 区进行新对象的空间分配
	- 如果此时 Survivor 区也已经没有内存空间了，则继续判断老年区，如果此时老年区空间充足，则将存活区中的活跃对象保存到老年代，而后 Survivor 区就会出现有空余空间，随后 Eden 区将活跃对象保存在 Survivor 之中，而后在 Eden 区里为新对象开辟空间
	- 如果这个时候老年代也满了，那么这个时候将产生 Major GC（Full GC），进行老年代的内存清理。
	- 如果老年代执行了 Full GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常「OutOfMemoryError」

- 两个常见异常原因总结

	- StackOverflowError

		- 线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常
		- 递归可能造成 StackOverflowError
		- 不断创建线程可能造成 StackOverflowError
		- 栈的深度（大小类似于弹夹深度）可以自动扩展，扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常
		- 和虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

	- OOM

		- 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常
		- 当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常
		- 各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError 异常。
		- 当一个线程抛出 OOM 异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行

- G1

	- 控制回收垃圾的时间：这个是 G1 的优势，可以控制回收垃圾的时间，还可以建立停顿的时间模型，选择一组合适的 Regions 作为回收目标，达到实时收集的目的

		- JVM 在初始化的时候，会为堆（heap），栈（stack），元数据区（matespace）分配指定的内存大小，JVM 线程启动的时候会向服务器申请指定的内存地址空间进行分配。
		- jdk8 之后，使用了 G1 垃圾回收器，逻辑上依然存在堆、栈、元数据区。
		- 在物理结构上，G1 采用了分区（Region）的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。
		- 在堆的使用上，G1 并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。
		- 启动时可以通过参数 -XX:G1HeapRegionSize=n 可指定分区大小（1MB ~ 32MB，且必须是 2 的幂)，默认将整堆划分为 2048 个分区。

	- 空间整理：和 CMS 一样采用标记-清理（整体上是标记-整理算法）的算法，但是 G1 不会产生空间碎片，这样就有效的使用了连续空间，不会导致连续空间不足提前造成 GC 的触发
	- G1 把 Java 内存拆分成多等份，多个域（Region），逻辑上存在新生代和老年代的概念，但是没有严格区分；Region 最多分为 2048个。
	- 在 CMS 内存中，如果一个对象过大，进入 S1、S2 区域的时候大于改分配的区域，对象会直接进入老年代。G1 处理大对象时会判断对象是否大于一个 Region 大小的 50%，如果大于 50% 就会横跨多个 Region 进行存放
	- 使用 G1 的场景

		- 实时数据占用超过一半的堆空间
		- 对象分配或者晋升的速度变化大
		- 希望消除长时间的GC停顿（超过0.5-1秒）

### 内存分配与回收策略

- Minor GC

	- 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。
	- 每次 Minor GC 会清理年轻代的内存。

- Major GC

	- 清理老年代

- Full GC（Stop The World，全世界的暂停）

	- 清理整个堆空间—包括年轻代和老年代。
	- 清理永久代

		- 废弃常量
		- 无用类

			- 该类所所有的对象实例已经被回收，也就是 Java 堆中不存在该类的任何实例
			- 加载该类的 ClassLoader 已经被回收
			- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

		- 产生条件

		  频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久带不会溢出。

			- 大量使用反射
			- 动态代理（CGLib、JDK 动态代理）

	- 触发条件一、显式调用 System.gc() 方法
	- 触发条件二、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够；
	- 触发条件三、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小，则触发一次 Full GC。

- Young GC

	- 清理年轻代
	- 触发条件：对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC

## JVM 常用优化方案

参考美团技术团队，原文地址：
https://tech.meituan.com/2017/12/29/jvm-optimize.html

### 优化前的准备

- GC 优化需知

	- GC相关基础知识

		- GC 工作原理
		- 理解新生代、老年代、晋升等术语含义
		- 要看懂GC日志

	- GC 优化不能解决一切性能问题，它是最后的调优手段。
	- JVM 调优可以理解为本质就是为了减少 Full GC的出现。

- JVM 基础回顾

	- JVM 内存结构

		- 分代回收，针对不同声明周期的对象采取不同的回收方式，提高回收效率
		- 新生代

			- 大多数对象在新生代中被创建，很对对象声明周期很短。每次 Minor GC 后只有少量对象存活，所以采用复制算法
			- 一个 Eden 区

				- 大部分对象在 Eden 区中生成，Eden 区满将依然存活的对象复制到两个 Survivor 区中的一个

			- 两个 Survivor 区

				- 当一个 Survivor 区满的时候，不满足晋升条件的对象会被复制到另一个 Survivor 区，满足晋升条件的会被放到老年代

			- 在 Serial 和 ParNew GC 回收期中，晋升年龄阈值通过参数「MaxTenuringThreshold」设定，默认值 15

		- 老年代

			- 在新生代中经历了 N 次垃圾回收仍然存活就回被放到老年代，此区域对象存活率高
			- 老年代的垃圾回收叫做「Major GC」，通常使用「标记-整理」、「标记-清除」算法
			- 新生代和老年代一起回收也就是整个堆回收叫做「Full GC」

	- 常见垃圾回收器

		- Serial 串行回收器

			- 单线程回收器，简单、易实现、效率高

		- ParNew 并行回收器

			- Serial 的多线程版本，可以充分利用 CPU 资源，减少回收时间

		- Parallel Scavenge 吞吐量优先回收器

			- 侧重于吞吐量的控制，吞吐量 = 运行业务代码的时间/(运行业务代码的时间+垃圾回收时间)

		- CMS 并发标记清除回收器

			- 以获取最短回收停顿时间为目标的回收器，基于「标记-清除」算法实现

		- G1 回收器

			- 对分区为一个个相同的「region」的可预测暂停时间的垃圾回收器

	- GC日志

- 参数基本策略

	- 活跃数据的大小

		- 应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是 Full GC 后堆中老年代占用空间的大小

	- 以活跃大小为 300M 为例

		- 总堆：300 * 4 = 1200M
		- 新生代：300 * 1.5 = 450M
		- 老年代：1200 - 450 = 750M

### 优化步骤

- 确定目标

	- 高可用：可用性达到几个 9
	- 低延迟：请求必须多少毫秒内完成响应
	- 高吞吐：每秒完成多少次事务

- 优化参数

	- 合适的 GC 回收器
	- 重新设置内存比例
	- 调整 JVM 参数

- 验收结果

### GC 优化案例（垃圾回收器均为 ParNew + CMS，CMS 失败时 Serial Old 替补）

- Major GC和 Minor GC频繁

	- Minor GC频繁通常由于新生代空间较小，Eden 区很快被填满，导致频繁 Minor GC，可以通过增大新生代空间来降低 Minor GC 的频率
	- 单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。
	- 扩容新生代空间后，Minor GC 频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC 频率自然也会降低。
	- 根据对象生命周期的分布情况

		- 如果应用存在大量的短期对象，应该选择较大的年轻代；
		- 如果存在相对较多的持久对象，老年代应该适当增大。

	- 动态年龄计算

		- Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 Survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

- 请求高峰期发生 GC，导致服务可用性下降

	- CMS 四个主要阶段

		- 初始标记

			- 进行可达性分析，标记 GC Roots 能直接关联到的对象

		- 并发标记

			- 初始标记过得对象重新出发，再次进行标记

		- 重新标记

			- Stop The World，重新进行可达性分析

		- 并发清理

			- 进行并发的垃圾清理

	- 新生代 GC 和老年代的 GC 是各自分开独立进行的
	- CMS 为了避免这个阶段没有等到 Minor GC 而陷入无限等待，提供了参数「CMSMaxAbortablePrecleanTime」，默认为 5s，含义是如果可中断的预清理执行超过5s，不管发没发生 Minor GC，都会中止此阶段，进入重新标记阶段。
	- CMS 提供 CMSScavengeBeforeRemark 参数，用来保证重新标记阶段之前强制进行一次 Minor GC。

- 发生 Stop The World 的 GC

	- 触发 Full GC 的可能情况

		- 元空间内存不足
		- CMS GC 时出现 promotion failed 和concurrent mode failure
		-  统计得到的 Young GC 晋升到老年代的平均大小大于老年代的剩余空间
		- 主动触发 Full GC 来避免内存空间碎片问题

	- 启动时将元空间大小固定，避免进行动态扩容。
	- JDK8 及以上版本，已经移除了永久代的概念，字符串常量已经移至到堆内存中，其余内容如类元信息、字段、静态属性、方法、常量等放入堆空间中。区别于永久代，元空间在本地内存中进行分配。

### 总结

- 进行 GC 优化之前，需要确认项目的架构和代码等已经没有优化空间
- 不要为了调优而调优，不当的调优可能适得其反

## JVM 线程模型

### JVM 其实就是操作系统的一种镜像，是软件层次的虚拟机

### 在 HotSpot 中的线程模型使用的是一个线程实例（java.lang.Thread）对应一个操作系统线程（这里的对应的是 LWP）。当一个线程实例开始执行 start() 的时候的时候就会创建一个 LWP 进行对应，并且在线程任务结束后回收，其中线程的调度由操作系统负责。

- 创建一个堆中的 Thread 对象（java.lang.Thread）
- 在 JVM 内部会创建一个 JavaThread 对象（JVM 内部的，称为 VmThread），用以维护线程当前的状态。同时 VmThread 会持有 java.lang.Thread 的引用及与操作系统对应的 OSThread 的引用
- JVM 内部会维护一个 OSThread，包含操作系统信息，及与实际操作系统线程对应的 handle。

## Java 对象内存布局及占用内存大小计算

### 对象的内存布局

- 对象头

	- Mark Word

		- 包含一系列的标记位

			- 锁状态（默认无锁）
			- 对象的 hashCode（25位）
			- 对象分代年龄（4位）
			- 是否是偏向锁（1位）
			- 锁标志位（2位）

				- 在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化

		- 在 32 位系统占 4 字节，在 64 位系统中占 8 字节；

	- Class Pointer

		- 用来指向对象对应的 Class 对象（其对应的元数据对象）的内存地址。
		- 在 32 位系统占 4 字节，在 64 位系统中占 8 字节；

	- Length

		- 如果是数组对象，代表保存数组长度的空间，占 4 个字节；

	- 在 32 位系统下，存放 Class Pointer 的空间大小是 4 字节，MarkWord 是 4 字节，对象头为 8 字节;
	- 在 64 位系统下，存放 Class Pointer 的空间大小是 8 字节，MarkWord 是 8 字节，对象头为16字节;
	- 64 位开启指针压缩的情况下，存放 Class Pointer 的空间大小是 4 字节，MarkWord 是 8字节，对象头为12字节;
	- 如果是数组对象，对象头的大小为：数组对象头 8 字节 + 数组长度4字节  +对齐 4 字节 = 16 字节。其中对象引用占 4 字节（未开启指针压缩的 64 位为 8 字节），数组 MarkWord 为 4 字节（64位未开启指针压缩的为 8 字节）;
	- 静态属性不算在对象大小内。

- 实例数据

	- 包括了对象的所有成员变量，其大小由各个成员变量的大小决定

		- byte 和 boolean 是 1 个字节
		- short 和 char 是 2 个字节
		- int 和 float 是 4 个字节
		- long 和 double 是 8 个字节
		- reference 引用类型是 4 个字节（64 位系统中是 8 个字节）

- 对齐填充

	- 所有 Java 对象占用 bytes 字节数必须是 8 的倍数

- 指针压缩

	- Ordinary Object Pointer，就是普通对象指针。

		- 64 位 JVM 消耗的内存会比 32 位的要多大约 1.5 倍，这是因为对象指针在 64 位 JVM 下有更宽的寻址。

	- -XX:+UseCompressedOops JVM 参数可以启用指针压缩
	- 压缩的对象

		- 每个 Class 的属性指针（静态成员变量）
		- 每个对象的属性指针
		- 普通对象数组的每个元素指针

