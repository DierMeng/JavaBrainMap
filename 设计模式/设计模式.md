# 设计模式

## 六个创建型模式

### 简单工厂模式-Simple Factory Pattern

- 定义

	- 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。
	- 因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式

- 角色

	- Factory（工厂角色）

		- 工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；
		- 工厂类可以被外界直接调用，创建所需的产品对象；
		- 工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型Product。

	- Product（抽象产品角色）

		- 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法
		- 提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。

	- Concreateproduct（具体产品角色）

		- 它是简单工厂模式的创建目标，所有被创建的对象都充
		- 当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在
		- 抽象产品中声明的抽象方法。

- 优缺点

	- 优点

		- 对象创建和使用的分离

			- 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅「消费」产品

		- 客户端不需要知道具体产品的类名

			- 只需要知道具体产品类所对应的参数即可

		- 根据「开放-封闭」原则，具体产品类的参数可以通过配置文件实现动态传参

	- 缺点

		- 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。
		- 势必会增加系统中类的个数
		- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑
		- 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构

- 适用场景

	- 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
	- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

### 工厂方法模式-Factory Method Pattern

- 定义

	- 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。
	- 工厂方法模式又简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。

- 结构及角色

	- Product（抽象产品）

		- 定义产品或者业务行为的接口，是工厂方法模式所创建对象的父类型。

	- ConcreteProduct（具体产品）

		- 也就是抽象产品或者业务行为的具体实现，不过这种具体的产品类型实例要由对应的具体工厂来创建。

	- Factory（抽象工厂）

		- 抽象工厂中声明的就是工厂方法，可以理解为返回的是上面的抽象产品，抽象工厂是工厂方法模式的核心，所有创建对象的具体工厂都必须实现该抽象工厂。

	- ConcreteFactory（具体工厂）

		- 抽象工厂的具体实现，实现抽象工厂中定义的工厂方法

- 优势

	- 用户只需要关心产品对应的工厂，不需要关心产品的创建细节，甚至不需要知道具体的产品名称。
	- 符合面向对象编程中的多态定义
	- 完全符合「开放-封闭原则」

- 劣势

	- 新增产品的时候还需要增加对应的工厂类，对于大型系统设计，类的数量指数级增加
	- 多层抽象固有的理解难度。

- 适用场景

	- 客户端不知道他所需要的对象的类。
	- 利用面向对象和里氏代换原则，程序运行时，子类对象可以覆盖父类对象，从而对系统进行扩展。

### 抽象工厂模式-Abstract Factory Pattern

### 单例模式-Singleton Pattern

保证一个类有且仅有一个实例,并提供一个访问它的全局访问点。

- 懒汉式单例

  顾名思义，就像你写代码的时候一定写过类似的「lazy=true」的代码，什么意思呢？就是这哥们比较懒，你让我干活，我才起床穿衣服给你干活，否则我猫着不出来活动。这种要在第一次被引用时，才会将自己实例化，所以就被称为懒汉式单例。

	- 第一次使用时创建实例
	- 无须一直占用系统资源
	- 必须考虑多线程问题

- 饿汉式单例

  顾名思义，就是它比较饥饿，在类初始化的时候你就杀愣的给人家的实例创建出来供别人使用。这种静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为饿汉式单例。

	- 类加载的时候即被创建
	- 无须考虑多线程，确保唯一性
	- 占用系统资源

- 并发条件下的懒汉式单例

	- volatile关键字修饰静态变量

	  被 volatile 修饰的成员变量可以确保多个线程都能够正确处理。

	- 双重锁定

	  如果 instance 为 null 并且这个有两个线程在调用 getInstance() 方法，他们都通过了第一重检查，然后因为锁的原因只能进去一个线程，另外一个被阻塞。如果这个时候没有第二重检查，那么第一个线程创建了实例，他出去的时候第二个线程进来还能创建新的实例，单例变成双例，那不扯淡呢吗？所以双重锁定必须加。

- 按需初始化单例（极致完美）

  按需初始化（Initialization on Demand Holder，简称 IoDH）的技术，该技术解决了饿汉式单例不能实现延迟加载，解决了懒汉式单例因为线程安全控制带来的性能和代码繁琐的诟病！

	- 声明静态内部类初始化静态变量

	  内部类中定义了一个 static 类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。

	- 保证单例不被反射破坏

		- 在私有构造中增加 instance 判断标识

	- 保证序列化下单例不被破坏

		- 在单例类中增加 readResolve() 方法并返回 instance 即可
		- readResolve() 方法与 writeReplace() 相对应，在反序列化之后(readObject() 之后)被调用，它会返回应该得到的没被 writeReplace() 替换之前的序列化对象

### 原型模式-Prototype Pattern

- 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
- Java 的 Object 对象中提供了 clone() 方法，一般重写这个方法也就可以完成原型模式了。

	- clone()

		- 浅拷贝、浅克隆

			- 被赋值对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象

		- 深拷贝、深克隆

			- 把引用对象的变量指向复制到的新对象，而不是原有的被引用的对象
			- 一、构造函数，调用构造函数时进行深拷贝
			- 二、重载 clone() 方法
			- 三、序列化

- 优点优势

	- 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又对性能是大大的提高。
	- 不用重新初始化对象，二十动态地获得对象运行时的状态

### 建造者模式-Builder Pattern

- 讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
- 用户只需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了
- 定义

	- 讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

- 角色

	- Builder

		- 是为创建一个 Product 对象的各个部件指定的抽象接口

	- ConcreteBuilder

		- 具体的建造者，实现 Builder 接口，构造和装配各个部件。

	- Product

		- 具体的产品、角色

	- Director

		- 指挥者，用来根据客户端的需求构建对象，是构建一个使用 Builder 接口的对象

- 适用场景

	- 主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。
	- 在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时使用的模式
	- 创建对象参数过多的时候
	- 对象的部分属性是可选择的时候
	- 对象创建完成后，就不能修改内部属性的时候

- 优劣势

	- 好处是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以如果需要改变一个产品的内部表示，只需要再定义一个具体的建造者

- 建造者模式与工厂模式的区别

	- 建造者模式，通过设置不同的可选参数，「定制化」的创建不同的对象
	- 工厂模式，是直接创建不同但是相关类型的对象

## 十一个行为型模式

### 职责链模式-Chain of Responsibility Pattern

### 命令模式-Command Pattern

### 解释器模式-Interpreter Pattern

### 迭代器模式-Iterator Pattern

### 中介者模式-Mediator Pattern

### 备忘录模式-Memento Pattern

### 观察者模式-Observer Pattern

- 定义

	- 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

- 角色及结构

	- Subject（目标）

		- 目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法 notify。目标类可以是接口，也可以是抽象类或具体类。

	- ConcreteSubject（具体目标）

		- 具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。

	- Observer（观察者）

		- 观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update，因此又称为抽象观察者。

	- ConcreteObserver（具体观察者）

		- 在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update 方法。通常在实现时，可以调用具体目标类的 attach 方法将自己添加到目标类的集合中或通过 detach 方法将自己从目标类的集合中删除。

- 优点

	- 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
	- 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
	- 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
	- 观察者模式满足「开闭原则」的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

- 缺点

	- 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。
	- 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
	- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

- 适用场景

	- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。
	- 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。
	- 需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象，可以使用观察者模式创建一种链式触发机制。

### 状态模式-State Pattern

- 定义

	- 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。其别名为状态对象（Objects for States）。

- 角色及结构

	- Context（环境类）

		- 环境类又称为上下文类，它是拥有多种状态的对象。
		- 由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。
		- 在环境类中维护一个抽象状态类 State 的实例，这个实例定义当前状态，在具体实现时，它是一个 State 子类的对象。

	- State（抽象状态类）

		- 它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。

	- ConcreteState（具体状态类）

		- 它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。

- 优势

	- 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，消除庞大的条件分支语句。
	- 状态的集中管理，封装状态的转换规则，这样我们只需要注入不同状态的状态对象到环境类当中就能实现对象的不同行为。
	- 状态共享。减少系统对象。

- 劣势

	- 有多少种状态就有多少个具体的状态类，系统开销大了
	- 状态对象与环境类对象构造混杂，复杂点状态对象行为会导致代码结构混乱。
	- 状态模式并不是完善的满足开放-封闭原则，无论是新增/修改状态都需要修改对应类的源码，不过总比错综复杂的条件分支语法强太多。

### 策略模式-Strategy Pattern

- 定义

	- 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
	- 所有这些算法完成的都是相同的工作，但是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。

- 角色及结构

	- Context（环境类）

		- 环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。
		- 在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。就是我们所说的业务场景类。

	- Strategy（抽象策略类）

		- 它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。
		- 环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。就是定义算法的接口。

	- ConcreteStrategy（具体策略类）

		- 它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。就是具体的算法。

- 优势

	- 算法重用
	- 消除条件判断语句
	- 完美符合「开放-封闭原则」

- 劣势

	- 策略模式只适用于客户端知道所有的算法或行为的情况。因为客户端必须知道所有的策略类，并自行决定使用哪一个策略类。所以就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。
	- 会导致具体策略类累积的越来越多。细小的变化都需要新增一个策略类来实现。
	- 客户端只能使用一个策略，无法同时多个。

- 适用场景

	- 某系统需要在多种算法中选择一种。
	- 某个对象有很多行为和选择

### 模板方法模式-Template Method Pattern

- 定义

	- 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

- 角色及结构

	- AbstractClass（抽象类）

		- 在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。
		- 在抽象类中实现了一个模板方法，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。

	- ConcreteClass（具体子类）

		- 它是抽象类的子类,用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。

- 优势

	- 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。
	- 鼓励我们使用继承实现代码复用
	- 通过抽象父类,不同的子类可以实现不同的行为,更换和新增子类方便,符合设计模式中的单一职责和开放-封闭原则。

- 劣势

	- 如果父类基本方法变得越来越多并且基本方法是多变类型，会导致子类的细节实现也越来越多，从而导致系统更加臃肿，此时也需要更进一步的抽象。

- 适用场景

	- 复杂算法分割，复杂业务流程分隔
	- 多个类都有共同的行为，可以提取抽象父类，在父类中直接声明并实现

### 访问者模式-Visitor Pattern

## 七个结构型模式

### 适配器模式-Adapter Pattern

- 定义

	- 将一个类的接口转换成客户希望的另外一个接口
	- 主要目的是解决由于接口不能兼容而导致类无法使用的问题，适配器模式会将需要适配的类转换成调用者能够使用的目标接口

- Adapter 适配器模式使得原本由于接口（这里的接口指的是广义的接口，它可以表示一个方法或者方法的集合）不兼容而不能一起工作的那些类可以一起工作。
- 角色结构

	- Target（目标抽象类）

		- 目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。可以理解为它就是电源适配器，里面声明或者实现了将高电压转为低电压的过程。

	- Adapter（适配器类）

		- 适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心。
		- 在对象适配器中它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。它可以理解为 Target 的具体实现的核心类，适配器模式就是通过这个适配器来协调适配者（220V 家庭用电）和客户端（笔记本电脑）之间的融合的。
		- Adapter 实现了 Target 接口，并包装了一个 Adaptee 对象。Adapter 在实现 Target 接口中的方法时，会将调用委托给 Adaptee 对象的相关方法，由 Adaptee 完成具体的业务。

	- Adaptee（适配者类、需要适配的类）

		- 适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。
		- 有真正的业务逻辑，但是其接口不能被调用者直接使用

- 优势

	- 目标类与适配者解耦，通过引用适配器，各自维护
	- 提高适配者的复用性
	- 可以方便的添加或者替换适配以适配不同的需求，符合开放 - 封闭原则
	- 一个适配器可以将多个不同的适配者适配到 target 目标类中
	- 可以适配适配者的子类，根据里氏代换原则，适配者的子类可以通过适配器来适配，毕竟适配器与适配者是关联关系。适配者在适配器中做声明和实例化。

- 适用场景

	- 对接系统没有源代码
	- 对接的系统的接口不能符合当前系统的接口规范
	- 对接系统的接口需要复用，不能对其有侵入和耦合。

### 桥接模式-Bridge Pattern

### 组合模式-Composite Pattern

### 装饰模式-Decorator Pattern

- 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活
- Component：定义一个对象接口，可以给这些对象动态地添加职责

	- ConcreteComponent：定义了一份具体的对象，可以给这个对象添加核心职责

		- Operation()

	- Decorator：装饰抽象类，扩展 Component 类的功能，但是 Component 无须知道 Decorator 的存在

		- ConcreteDecoratorA
		- ConcreteDecoratorB

- 装饰模式是为已有功能动态地添加更多功能的一种方式
- 把类中的装饰功能从类中搬移取去除，简化原有的类。有效的把类的核心职责和装饰功能区分。

### 外观模式-Facade Pattern

- 定义

	- 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

- 角色及结构

	- Facade（外观角色）

		- 在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；
		- 在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。

	- SubSystem（子系统角色）

		- 软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；
		- 每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。

- 优势

	- 对客户端屏蔽子系统，封装子系统，是客户端调用方便简单，减少客户端与子系统的关联，降低耦合。
	- 子系统的修改保持独立，某个子系统的修改不影响其他系统。这也是分层设计的体现。

- 劣势

	- 对于限制客户端与子系统的交互并不完美，同时所有的业务逻辑全被外观类封装的话会影响系统的可变性以及灵活性。幸好外观模式不影响客户端可以直接调用子系统。
	- 违背开放-封闭原则

### 享元模式-Flyweight Pattern

### 代理模式-Proxy Pattern

- 为其他对象提供一种代理以控制对这个对象的访问。即给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
- 代理模式的结构及角色

	- Subject（抽象主题角色）

		- 声明真实对象和代理对象的共同接口，保证在使用真实对象的地方都可以使用代理对象
		- 程序中的业务逻辑接口

	- Proxy（代理主题角色）

		- 代理对象需要包含对真实对象的引用，从而可以在任何时候任何地点保证对真实对象的调用，甚至对真实对象的约束和修饰。
		- 实现了 Subject 接口的代理类，封装了 RealSubject 对象

	- RealSubject（真实主题角色）

		- 实现真正的核心业务逻辑，客户端通过代理，代理再通过调用真实对象实现的核心操作完成业务逻辑
		- 实现了 Subject 接口的真正业务类
		- 在程序中不会直接调用 RealSubject 对象的方法，而是使用 Proxy 对象实现相关功能

- 代理模式的类型

	- 远程代理：为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
	- 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象
	- 安全代理：用来控制真实对象访问时的权限。
	- 智能指引，是指当调用真实的对象时，代理处理另外一些事实。
	- 缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端 可以共享这些结果。

- 优势

	- 代理模式可以实现「延迟加载」
	- 可以协调调用者与 RealSubject 之间的关系，一定程度上实现了解耦

## 七个面向对象设计原则

### 单一职责原则-Single Responsibility Principle

- 就一个类而言，应该仅有一个引起它变化的原因。
- 一个类应该只负责负责一个功能领域中的相应职责，不要多管闲事。

### 开闭原则-Open-Closed Principle

- 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

### 里氏代换原则-Liskov Substitution Principle

- 子类型必须能够替换掉它们的父类型。

### 依赖倒转原则-Dependency Inversion Principle

- 抽象不应该依赖细节，细节应该依赖于抽象
- 高层模块不应该依赖低层模块。两个都应该依赖抽象。
- 要针对接口编程，不要对实现编程。

### 接口隔离原则-Interface Segregation Principle

- 一个类对另一个类的依赖应该建立在最小的接口上
- 说白了就是我们在设计接口时，不要设计出庞大臃肿的接口，因为实现这种接口时需要实现很多不必要的方法。
- 尽量设计出功能单一的接口，这样也能保证实现类的职责单一。

### 合成复用原则-Composite Reuse Principle

### 迪米特法则（Law of Demeter），也叫「最少知识原则」

- 如果两个类不彼此直接通信，那么这两个类就不应当发生直接的相互作用。
- 一个软件实体应当尽可能少地与其他实体发生相互作用。

