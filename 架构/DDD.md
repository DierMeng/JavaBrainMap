# DDD

## 第一部分 运用领域模型

### 模型的选择

- 模型和设计的核心互相影响。
- 模型是团队所有成员使用的通用语言的中枢。
- 模型是浓缩的知识。

### 软件的核心

- 为用户解决领域相关的问题的能力。

### 第一章 消化知识

- 有效建模的要素

	- 模型和实现的绑定。
	- 建立了一种基于模型的语言。
	- 开发一个蕴含丰富知识的模型。
	- 提炼模型。
	- 头脑风暴和实验。

- 明确设计的优点

	- 为了实现更明确的设计，程序员和其他各位相关人员都必须理解超订的本质，明白它是一个明确且重要的业务规则，而不只是一个不起眼的计算。
	- 程序员可以向业务专家展示技术工件，甚至是代码，但应该是领域专家（在程序员指导下）可以理解的，以便形成反馈闭环。

### 第二章 交流与语言的使用

- 2.1 模式：UBIQUITOUS LANGUAGE
- 2.2 「大声地」建模
- 2.3 一个团队，一种语言
- 2.4 文档和图

	- 书面设计文档
	- 完全依赖可执行代码的情况

- 2.5 解释性模型

### 第三章 绑定模型和实现

- 3.1 模式：MODEL-DRIVEN DESIGN（模型驱动设计）

	- 基本要素

		- 模型要支持有效的实现
		- 抽象出关键的领域知

- 3.2 建模范式和工具支持
- 3.3 揭示主旨：为什么模型对用户至关重要
- 3.4 模式：HANDS-ON MODELER（亲身实践的建模者）

## 第二部分 模型驱动设计的构造块

### 第四章 分离领域

- 4.1 模式：LAYERED ARCHITECTURE

	- 用户界面层（表示层）
	- 应用层
	- 领域层（模型层）
	- 基础设施层

### 第五章 软件中所表示的模型

- 3 种模型元素模式

	- ENTITY
	- VALUE OBJECT
	- SERVICE

- 5.1 关联

	- 规定一个遍历方向
	- 添加一个限定符，以便有效地减少多重关联
	- 消除不必要的关联

- 5.2 模式：ENTITY（又称为REFERENCE OBJECT）

	- 主要由标识定义的对象被称作 ENTITY
	- ENTITY建模
	- 设计标识操作

- 5.3 模式：VALUE OBJECT

	- 用于描述领域的某个方面而本身没有概念标识的对象称为VALUE OBJECT（值对象）

- 5.4 模式：SERVICE

	- 特征

		- 与领域概念相关的操作不是ENTITY或VALUE OBJECT的一个自然组成部分。
		- 接口是根据领域模型的其他元素定义的。
		- 操作是无状态的。

- 5.5 模式：MODULE（也称为PACKAGE）

### 第六章 领域对象的生命周期

### 第七章 使用语言：一个扩展的示例

## 杂记

### 贫血模型与充血模型

- 贫血模型

	- 领域对象的作用很简单，只有所有属性的get/set方式，以及少量简单的属性值转换，不包含任何业务逻辑，不关系对象持久化，只是用来做为数据对象的承载和传递的介质。
	- 真正的业务逻辑则由领域服务负责实现，此服务引入持久化仓库，在业务逻辑完成之后持久化到仓库中，并在此可以发布领域事件
	- 优点

		- 结构简单，职责单一，相互隔离性好，使用单例模型提高运行性能

	- 缺点

		- 对象状态与行为分离，不能直观地描述领域对象。
		- 行为的设计主要考虑参数的输入和输出而非行为本身，不太具有面向对象设计的思考方式。
		- 行为间关联性较小，更像是面向过程式的方法，可复用性也较小。

	- SpringBoot 采用单例模式，尽量不手动创建对象，对象无状态化，故较推荐使用贫血模型

- 充血模型

	- 领域对象作用此领域相关行为，包含此领域相关的业务逻辑，同时也包含对领域对象的持久化操作。
	- 优点

		- 对象自洽程度很高，表达能力很强，因此非常适合于复杂的企业业务逻辑的实现，以及可复用程度比较高，更符合面向对象设计思想

	- 缺点

		- 对象属性中掺杂持久化仓库，不够纯粹，持久化操作是否属于业务逻辑有待求证。
		- 由于持久化仅需暴露接口，对业务逻辑与持久化操作的耦合度有一定降低。

- 充血模型2

	- 了解决业务逻辑不纯粹问题，也有将持久化操作移出业务逻辑的作法。
	- 优点

		- 保持了业务逻辑的纯粹性，去掉了持久化的入侵

	- 缺点

		- 降低了领域服务的自治性，破坏了行为逻辑的完整性，部分逻辑混入了应用层，尤其是领域事件的发布

	- 前两种方式的折中，充分地做到了解耦，但也牺牲了部分内聚

