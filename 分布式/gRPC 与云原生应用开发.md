# gRPC 与云原生应用开发

## 一、gRPC 入门

### 微服务架构

- 微服务架构将软件应用程序构建为一组独立、自治（独立开发、部署和扩展）、松耦合、面向业务能力的服务

### RESTful 局限性

- 基于文本的低效消息协议
- 应用程序之间缺乏强类型接口
- REST 架构风格难以强制实施

### 编排/解排

- 编排（marshal）

	- 将参数和远程函数打包的过程

- 解排（unmarshal）

	- 解包消息到对应的方法调用的过程

### 进程间通信技术

- 传统的 RPC

	- CORBA（通用对象请求代理体系结构）
	- RMI（Java 远程方法调用）
	- 弊端：构建在 TCP 通信协议之上，妨碍互操作性，还有大量的规范限制

-  SOAP（简单对象访问协议）

	- 面向服务的架构（SOA）中的标准通信技术
	- 用于在服务之间交换基于 XML 的结构化数据，能够基于任意的底层通信协议进行通信，最常用的是 HTTP
	- 弊端：消息格式复杂，规范复杂

- REST

	- 面向资源的结构（ROA）的基础，通用实现是 HTTP
	- 弊端：基于文本的低效消息协议；应用程序之间缺乏强类型接口；REST架构风格难以强制实施；

- gRPC

	- 优势

		- 提供高效的进程间通信
		- 具有简单且定义良好的服务接口和模式
		- 属于强类型
		- 支持多语言
		- 支持双工流
		- 具备内置的商业化特性
		- 与云原生生态系统进行了集成

	- 劣势

		- gRPC 可能不太适合面向外部的服务
		- 巨大的服务定义变更是复杂的开发流程
		- gRPC生态系统相对较小

## 二、开始使用 gRPC 

### 消息（message）是客户端和服务器端交换的数据结构。

## 三、gRPC 的通信模式

### 一元 RPC 模式（简单 RPC 模式）

- 当客户端调用服务器端的远程方法时，客户端发送请求至服务器端并获得一个响应，与响应一起发送的还有状态细节以及 trailer 元数据。
- 一元RPC模式中，gRPC 服务器端和 gRPC 客户端在通信时始终只有一个请求和一个响应

### 服务端流 RPC 模式

- 服务器端在接收到客户端的请求消息后，会发回一个响应的序列。这种多个响应所组成的序列也被称为「流”」，在将所有的服务器端响应发送完毕之后，服务器端会以 trailer 元数据的形式将其状态发送给客户端，从而标记流的结束。

### 客户端流 RPC 模式

- 客户端会发送多个请求给服务器端，而不再是单个请求。
- 服务器端会发送一个响应给客户端。但是，服务器端不一定要等到从客户端接收到所有消息后才发送响应。
- 可以在接收到流中的一条消息或几条消息之后就发送响应，也可以在读取完流中的所有消息之后再发送响应。

### 双向流 RPC 模式

- 客户端以消息流的形式发送请求到服务器端，服务器端也以消息流的形式进行响应。
- 调用必须由客户端发起，但在此之后，通信完全基于 gRPC 客户端和服务器端的应用程序逻辑。
- 流的操作完全独立，客户端和服务器端可以按照任意顺序进行读取和写入，一旦建立连接，客户端和服务器端之间的通信模式就完全取决于客户端和服务器端本身。

### 使用 gRPC 实现微服务通信

## 四、gRPC 的底层原理

### RPC 流

- https://pic.imgdb.cn/item/6246d59727f86abb2ab3c1a5.jpg
protocol buffers 作为 gRPC 的编码技术，HTTP/2 作为 gRPC 的通信协议
- RPC 系统中，服务器端会实现一组可以远程调用的方法。客户端会生成一个存根，该存根为服务器端的方法提供抽象。这样一来，客户端应用程序可以直接调用存根方法，进而调用服务器端应用程序的远程方法。

### 使用 protocol buffers 编码消息

- 编码技术

	- Varint 类型（可变长度整数）

		- 使用单字节或多字节来序列化整数的方法

	- 有符号整数类型

		- 有符号类型，会使用 zigzag 编码来将有符号整数转换成无符号整数。无符号整数会使用前面的 Varint 编码技术来进行编码。

	- 非 Varint 类型

		- 分配固定数量的字节，字节数与实际值没有关系

			- 64 位的数据类型
			- 32 位的数据类型

	- 字符串类型

		- 字符串类型属于基于长度分隔的线路类型，首先会有一个经过 Varint 编码的长度值，随后才是指定数量的字节数据

### 基于长度前缀的消息分帧

- 在写入消息本身之前，写入长度信息，来表明每条消息的大小，每条消息都有额外的 4 字节用来设置其大小，意味着 gRPC 通信可以处理大小不超过 4GB 的所有消息
- 帧中还有单字节的无符号整数，用来表明数据是否进行了压缩

	- 0 - 没有进行压缩
	- 1 - 使用 Message-Encoding 头信息中声明的机制进行了压缩

- 对于简单的消息，只需处理一条以长度为前缀的消息；而对于流消息，就会有多条以长度为前缀的消息要处理。

### 基于 HTTP/2 的 gRPC

- http/2 核心术语

	- 流

		- 在一个已建立的连接上的双向字节流。一个流可以携带一条或多条消息。

	- 帧

		- HTTP/2 中最小的通信单元。每一帧都包含一个帧头，它至少要标记该帧所属的流。

	- 消息

		- 完整的帧序列，映射为一条逻辑上的 HTTP 消息，由一帧或多帧组成。这样的话，允许消息进行多路复用，客户端和服务器端能够将消息分解成独立的帧，交叉发送它们，然后在另一端进行重新组合。

- https://pic.imgdb.cn/item/6246f02527f86abb2aeae969.jpg
主流程

	- gRPC 通道代表一个到端点的连接，也就是一个 HTTP/2 连接。
	- 客户端应用程序创建 gRPC 通道的时候，它会在幕后创建一个到服务器端的 HTTP/2 连接
	- 通道创建完成之后，就可以重用它来发送多个到服务器端的远程调用
	- 远程调用会映射为 HTTP/2 中的流，远程调用中的消息以 HTTP2 帧的形式进行发送，帧可以携带一条 gRPC 长度前缀消息，也可跨多帧

- 请求消息

	- 组成

		- 请求头信息
		- 以长度作为前缀的消息
		- 流结束标记

	- 当完成对服务器端调用的初始化之后，客户端会以 HTTP2 数据帧的形式发送以长度作为前缀的消息。如果这条消息不适合放到一个数据帧中，那么它可以跨多个数据帧。请求消息的结束通过在最后一个 DATA 帧上添加 END_STREAM 标记来实现。

- 响应消息

	- 组成

		- 响应头信息
		- 以长度作为前缀的消息
		- trailer
		- 如果没有发送以长度作为前缀的消息来响应客户端，则响应消息只会包含头信息和 trailer

	- END_STREAM 标记并不会随数据帧一起发送，而会作为单独的头信息来发送

- 理解 gRPC 通信模式中的消息流

	- https://pic.imgdb.cn/item/6246f7c027f86abb2afc9d88.jpg
一元 RPC 模式
	- https://pic.imgdb.cn/item/6246f8cb27f86abb2aff3921.jpg
服务端流 RPC 模式
	- https://pic.imgdb.cn/item/6246f90927f86abb2affd1cd.jpg
客户端流 RPC 模式
	- https://pic.imgdb.cn/item/6246f93f27f86abb2a004caf.jpg
双向流 RPC 模式

### gRPC 实现结构

## 五、gRPC：超越基础知识

## 六、安全的 gRPC

## 七、在生产环境中运行 gRPC

## 八、gRPC 的生态系统

