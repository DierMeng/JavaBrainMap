# 深入理解 JVM（第三版）

## 一、走近 Java

### 1、走近 Java

- 概述

	- 摆脱了硬件平台的束缚，实现了「一次编写，到处运行」的理想；它提供了一种相对安全的内存管理和访问机制，避免了绝大部分内存泄漏和指针越界问题；它实现了热点代码检测和运行时编译及优化，这使得Java应用能随着运行时间的增长而获得更高的性能；它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能

- Java 技术体系

	- Java 程序设计语言
	- 各种硬件平台上的 Java 虚拟机实现
	- Java 类库 API
	- Class 文件格式
	- 来自商业机构和开源社区的第三方 Java 类库
	- JRE（JavaRuntime Environment）

		- Java 类库 API 中的 Java SE API 子集
		- Java 虚拟机

	- Java 技术体系所包括的内容
https://pic.imgdb.cn/item/622ed3125baa1a80ababfbca.jpg

- Java 发展史

	- Java语言的前身：Oak，James Gosling 博士领导的绿色计划。
	- 1995年5月23日，Oak语言改名为Java，并且在SunWorld大会上正式发布Java 1.0版本。
	- 1996年1月23日，JDK 1.0发布，Java语言有了第一个正式版本的运行环境。
	- 1997年2月19日，Sun公司发布了JDK 1.1，JAR文件格式、JDBC、JavaBeans、RMI等。
	- 1998年12月4日，JDK迎来了一个里程碑式的重要版本：JDK 1.2，Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。
	- 1999年4月27日，HotSpot虚拟机诞生。
	- 2000年5月8日，JDK 1.3发布。
	- 2002年2月13日，JDK 1.4发布
	- 2004年9月30日，JDK 5发布
	- 2006年12月11日，JDK 6发布
	- 2009年2月19日，JDK 7完成了其第一个里程碑版本。
	- JDK 8的第一个正式版本原定于2013年9月发布，最终还是跳票到了2014年3月18日
	- JDK 9最终到2017年9月21日才得以面世。
	- 2018年3月20日，JDK 10如期发布
	- 2018年9月25日，JDK 11发布，这是一个LTS版本的JDK，包含17个JEP，其中有ZGC这样的革命性的垃圾收集器出现，也有把JDK 10中的类型推断加入Lambda语法这种可见的改进
	- 2019年3月20日，JDK 12发布

- Java 虚拟机家族

	- 虚拟机始祖：Sun Classic/Exact VM
	- 武林盟主：HotSpot VM

		- HotSpot 虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译行为

	- 小家碧玉：Mobile/Embedded VM
	- 天下第二：BEA JRockit/IBM J9 VM

		- IBM J9虚拟机的职责分离与模块化做得比HotSpot更优秀

	- 软硬合璧：BEA Liquid VM/Azul VM
	- 挑战者：Apache Harmony/Google Android Dalvik VM
	- 没有成功，但并非失败：Microsoft JVM及其他
	- 百家争鸣

		- KVM

			- K是「Kilobyte」的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。

		- Java Card VM
		- Squawk VM
		- JavaInJava
		- Maxine VM
		- Jikes RVM
		- IKVM.NET
		- JamVM、CacaoVM、SableVM、Kaffe、Jelatine JVM、NanoVM、MRP、Moxie JVM

- 展望Java技术的未来

	- Graal VM

		- 在 HotSpot 虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为「任何语言」的运行平台使用

	- 新一代即时编译器

		- HotSpot虚 拟机中的两个即时编译器

			- c1

				- 编译耗时短但输出代码优化程度较低的客户端编译器

			- c2

				- 编译耗时长但输出代码优化质量也更高的服务端编译器

		- 自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器

	- 向Native迈进

		- 提前编译是相对于即时编译的概念，提前编译能带来的最大好处是Java虚拟机加载这些已经预编译成二进制库之后就能够直接调用，而无须再等待即时编译器在运行时将其编译成二进制机器码。

	- 灵活的胖子

		- 面向各种不同应用场景的全功能Java虚拟机

	- 语言语法持续增强

		- Project Loom

			- 准备提供一套与目前Thread类API非常接近的更加轻量级的、由软件自身进行调度的用户线程

		- Project Valhalla

			- 提供值类型和基本类型的泛型支持，并提供明确的不可变类型和非引用类型的声明。

		- Project Panama

			- 消弭Java虚拟机与本地代码之间的界线。

- 实战：自己编译JDK

	- https://hg.openjdk.java.net/jdk/jdk12/

##  二、自动内存管理

### 2、Java内存区域与内存溢出异常

- 概述

	- 对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码

- 运行时数据区域
https://pic.imgdb.cn/item/6238088627f86abb2a62d829.jpg

	- 程序计数器（线程私有）

		- 一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
		- 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
		- 此内存区域是唯一一个没有规定任何OutOfMemoryError情况的区域。

	- Java虚拟机栈（线程私有）

		- 生命周期与线程相同
		- 描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
		- 局部变量表

			- 编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）
			- 对象引用（reference类型）
			- returnAddress类型
			- 局部变量槽（Slot）

				- 64位长度的long和double类型的数据会占用两个变量槽
				- 其余的数据类型只占用一个
				- 当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。（槽的数量）

		- StackOverflowError异常

			- 如果线程请求的栈深度大于虚拟机所允许的深度

		- OutOfMemoryError异常

			- 如果Java虚拟机栈容量可以动态扩展，但是栈扩展时无法申请到足够的内存

	- 本地方法栈（线程私有）

		- 与虚拟机栈所发挥的作用相似，只是虚拟机栈为虚拟机执行Java方法字节码服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

	- Java堆（线程共享）

		- 虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例
		- Java堆可以处于物理上不连续的内存空间中，但在逻辑上应该是连续的，但是向数组这样的以及一些大对象，会要求连续的内存空间
		- Java 堆大小的这是通过参数-Xmx和-Xms设定，主流虚拟均是可扩展的，无法扩展时，抛出OutOfMemoryError异常。

	- 方法区（线程共享）

		- 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
		- 除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。
		- 如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。
		- 运行时常量池

			- 方法区的一部分
			- Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
			- 具备动态性

				- 并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中
				- String类的intern()

			- 当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

	- 直接内存

		- 并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常

- HotSpot虚拟机对象探秘

	- 对象的创建

		- 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
		- 内存分配方式

			- 指针碰撞

				- Java 堆内存规整，使用过的内存和空闲的内存分别放在两边，中间放一个指针分配内存时就将指针向空闲空间方向罗东一段与对象大小相等的距离。
				- Serial、ParNew 垃圾收集器使用简单又高效的指针碰撞

			- 空闲列表

				- Java 堆内存不规整，已使用的和空闲的内存交错在一起，虚拟机会维护一个列表进行记录，分配的时候从列表中找到一块足够大的空间划分给对象，并且更新列表
				- CMS 等基于清除算法的垃圾收集器采用空闲列表方式分配内存

		- 内存分配并发处理

			- 采用 CAS 配上失败重试的方式更新操作的原子性
			- 把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲

	- 对象的内存布局

		- 对象在堆内存中的存储布局

			- 对象头（Header）

				- 存储对象自身的运行时数据（Mark Word）

					- 哈希码（HashCode）
					- GC分代年龄
					- 锁状态标志
					- 线程持有的锁
					- 偏向线程ID
					- 偏向时间戳
					- 数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特
					- Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。

				- 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

					- 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据

			- 实例数据（Instance Data）

				- 对象真正存储的有效信息

			- 对齐填充（Padding）

				- 并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
				- HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即任何对象的大小都必须是8字节的整数倍。
				- 如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

	- 对象的访问定位

		- 使用一个对象时，Java程序会通过栈上的 reference 数据来操作堆上的具体对象。
		- 对象访问方式

			- 使用句柄

				- Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息

https://pic.imgdb.cn/item/623bf8ab27f86abb2a0d8ab5.jpg

					- 好处是 reference 中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

			- 直接指针

				- reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销

https://pic.imgdb.cn/item/623bf8f027f86abb2a0f3713.jpg

					- 好处是速度更快，它节省了一次指针定位的时间开销
					- HotSpot 使用这种方式

- 实战：OutOfMemoryError异常

	- Java堆溢出

		- Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

			- 异常堆栈信息「java.lang.OutOfMemoryError」会跟随进一步提示『Java heap space』

		- 处理方法

			- 通过内存映像分析工具对 Dump 出来的堆转储快照进行分析。

				- 确认内存中导致OOM的对象是否是必要的，先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）

					- 内存溢出

						- 是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。

					- 内存泄漏

						- 指长期保持某些资源的引用，垃圾回收器无法回收它，从而造成该资源不能够及时释放，随着程序运行时间的增加，占用存储空间越来越多，致使有效可再利用的存储空间不足，当储存别的资源时引发内存溢出。
						- 内存泄露是造成内存溢出的一个很主要的原因

				- 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们
				- 如果不是内存泄漏，也就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。

	- 虚拟机栈和本地方法栈溢出

		- 两种异常

			- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
			- 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

		- HotSpot虚拟机的选择是不支持栈内存动态扩展，除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。

	- 方法区和运行时常量池溢出

		- String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。
		- 方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
		- JDK 8 元空间设置参数

			- -XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。
			- -XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。
			- -XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。

	- 本机直接内存溢出

		- 直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致

### 3、垃圾收集器与内存分配策略

- 概述

	- 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。
	- Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。

- 对象已死？

	- 引用计数算法

		- 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。
		- Java虚拟机并不是通过引用计数算法来判断对象是否存活的。
		- 引用计数很难解决对象之间相互循环引用的问题

	- 可达性分析算法

		- 通过一系列称为「GC Roots」的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为『引用链』（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。
		- 固定作为 GC Roots 的对象

			- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
			- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
			- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
			- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
			- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
			- 所有被同步锁（synchronized关键字）持有的对象。
			- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

	- 再谈引用

		- 引用类型

			- 强引用（StronglyRe-ference）

				- 强引用是最传统的「引用」的定义，是指在程序代码之中普遍存在的引用赋值，即类似『Object obj=new Object()』这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

			- 软引用（Soft Reference）

				- 描述一些还有用，但非必须的对象。

					- 只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

			- 弱引用（Weak Reference）

				- 描述那些非必须对象，强度比软引用更弱一些

					- 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
					- 当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

			- 虚引用（Phantom Reference）

				- 也称为「幽灵引用」或者『幻影引用』，它是最弱的一种引用关系。

					- 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
					- 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

	- 生存还是死亡

		- 对象死亡标记过程

			- 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记
			- 随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法

				- 对象没有覆盖finalize()方法
				- finalize()方法已经被虚拟机调用过

			- 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。

				- 任何一个对象的finalize()方法都只会被系统自动调用一次

	- 回收方法区

		- 回收内容

			- 废弃的常量
			- 不再使用的类型

		- 判定一个类型是否属于「不再被使用的类」

			- 该类所有的实例都已经被回收，Java 堆中不存在该类及其任何派生子类的实例。
			- 加载该类的类加载器已经被回收
			- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

- 垃圾收集算法

	- 垃圾收算法分类

		- 引用计数式垃圾收集（Reference Counting GC），也叫「直接垃圾收集」
		- 追踪式垃圾收集（Tracing GC），也叫「间接垃圾收集」

	- 分代收集理论

		- 分代假说

			- 弱分代假说（Weak Generational Hypothesis）

				- 绝大多数对象都是朝生夕灭的。

			- 强分代假说（Strong Generational Hypothesis）

				- 熬过越多次垃圾收集过程的对象就越难以消亡。

		- 多款常用的垃圾收集器的一致的设计原则

			- 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

		- 跨代引用假说（Intergenerational Reference Hypothesis）

			- 跨代引用相对于同代引用来说仅占极少数。

		- 收集类型

			- 部分收集（Partial GC）

				- 新生代收集（Minor GC/Young GC）

					- 指目标只是新生代的垃圾收集。

				- 老年代收集（Major GC/Old GC）

					- 指目标只是老年代的垃圾收集。
					- 目前只有CMS收集器会有单独收集老年代的行为。

				- 混合收集（Mixed GC）

					- 指目标是收集整个新生代以及部分老年代的垃圾收集。
					- 目前只有G1收集器会有这种行为。

			- 整堆收集（Full GC）

				- 收集整个Java堆和方法区的垃圾收集。

	- 标记-清除算法

		- 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象
		- 缺点

			- 执行效率不稳定

				- 标记和清除两个过程的执行效率都随对象数量增长而降低

			- 内存空间的碎片化问题

				- 标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

	- 标记-复制算法

		- 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块
		- 缺点

			- 可用内存缩小为了原来的一半，空间浪费太多
			- 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销

		- Appel 式回收

			- 把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。
			- 发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。
			- HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1

	- 标记-整理算法

		- 标记过程仍然与「标记-清除」算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存
		- 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动 式的。
		- Stop The World

			- 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行

- HotSpot 的算法细节实现

	- 根节点枚举

		- 所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的 Stop The World 的困扰。
		- 使用一组称为 OopMap 的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，并不需要真正一个不漏地从方法区等 GC Roots 开始查找。

	- 安全点

		- HotSpot 也的确没有为每条指令都生成OopMap，只是在「特定的位置」记录了这些信息，这些位置被称为安全点(Safepoint)。
		- 如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来

			- 抢先式中断

				- 不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。

					- 现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件。

			- 主动式中断

				- 当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

	- 安全区域

		- 能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

	- 记忆集与卡表

		- 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

			- 最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构

		- 字长精度

			- 每个记录精确到一个机器字长，包含跨代指针

		- 对象精度

			- 每个记录精确到一个对象，该对象里有字段含有跨代指针。

		- 卡精度

			- 每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
			- 卡表

				- 定义了记忆集的记录精度、与堆内存的映射关系等。

	- 写屏障

		- 卡表元素何时变脏

			- 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。

		- 在 HotSpot 虚拟机里是通过写屏障(Write Barrier)技术维护卡表状态的

	- 并发的可达性分析

		- 三色标记

			- 白色

				- 表示对象尚未被垃圾收集器访问过。
				- 可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。

			- 黑色

				- 表示对象己经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。
				- 是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。

			- 灰色

				- 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

		- 解决并发扫描时的对象消失问题

			- 增量更新

				- 当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。
				- 黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。

			- 原始快照

				- 当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。
				- 无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。

- 经典垃圾收集器

	- 收集器搭配、分配关系

		- https://pic.imgdb.cn/item/624fa55d239250f7c57d45d9.jpg

	- 基本术语概念

		- 并行

			- 多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。

		- 并发

			- 垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。
			- 由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

	- Serial 收集器

		- https://pic.imgdb.cn/item/624fab4c239250f7c58c3775.jpg
一个单线程工作的收集器，强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。即「Stop the World」
		- 优势

			- 简单而高效

				- 对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的
				- 对于单核处理器或处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
				- Serial 收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

	- ParNew 收集器

		- https://pic.imgdb.cn/item/624fab6f239250f7c58c9579.jpg
本质上是 Serial 收集器的多线程并行版本
		- 只有它能与 CMS 收集器配合工作
		- 默认开启的收集线程数与处理器核心数量相同

	- Parallel Scavenge 收集器

		- 新生代收集器，基于「标记-复制」，能够并行收集的多线程收集器
		- 目标

			- 其他垃圾收集器的目标是缩短垃圾收集时用户线程的停顿时间
			- Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量 

				- 运行用户代码的时间/(运行用户代码的时间+运行垃圾收集的时间)

	- Serial Old 收集器

		- https://pic.imgdb.cn/item/624fab9a239250f7c58d0a0b.jpg
Serial 收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法
		- 适用场景

			- JDK5 及之前与吞吐量收集器搭配之用
			- 客户端模式使用
			- CMS 并发收集失败的后备预案

	- Parallel Old 收集器

		- https://pic.imgdb.cn/item/624faaf6239250f7c58b580e.jpg
吞吐量收集器的老年代版本，支持多线程并发收集，基于标记-整理算法

	- CMS 收集器

		- https://pic.imgdb.cn/item/624fad34239250f7c59129e2.jpg
第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。
		- 老年代收集器

			- 无法与新生代收集器 Parallel Scavenge 收集器配合工作

		- 一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法
		- 运作过程

			- 初始标记(CMS initial mark)

				- Stop The World
				- 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快

			- 并发标记(CMS concurrent mark)

				- 从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

			- 重新标记(CMS remark)

				- Stop The World
				- 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
				- 停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短

			- 并发清除(CMS concurrent sweep)

				- 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

		- 缺点

			- 对处理器资源非常敏感

				- 并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。
				- 默认启动的回收线程数

					- (处理器核心数量+3)/4
					- 如果核心不足 4 个，占据一般的运算能力去执行收集器线程

			- 无法处理「浮动垃圾」

				- 在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS 无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为「浮动垃圾」

			- 收集结束时会有大量空间碎片产生

				- 空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Fu1lGC 的情况。

	- Garbage First 收集器

		- https://pic.imgdb.cn/item/624fb889239250f7c5ad5d7f.jpg
G1 是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。基于标记-整理收集算法

			- G1 面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式。

		- 停顿时间模型

			- 支持指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒这样的目标

		- 内存划分与布局

			- 仍然遵循分代收集理论，但是不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域(Region)，每一个 Region 都可以
根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。
			- Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。

				- G1 认为只要大小超过了一个Region 容量一半的对象即可判定为大对象。
				- G1 的大多数行为都把 Humongous Region 作为老年代 的一部分来进行看待

			- G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。

				- 具体的处理思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的「价值」大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些 Region

		- 运作过程

			- 初始标记

				- 仅仅只是标记一下 GC Roots 能直接关联到的对象，耗时很短，借用进行 Minor GC 的时候同步完成的，实际并没有额外的停顿。

			- 并发标记

				- 从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。

			- 最终标记

				- 对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB(原始快照) 记录。

			- 筛选回收

				- 负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧Region的全部空间。
				- 这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

- 低延迟垃圾收集器

	- 不可能三角

		- 内存占用
		- 吞吐量
		- 延迟

	- Shenandoaht 收集器

		- https://pic.imgdb.cn/item/624fbc51239250f7c5ba0ec1.jpg
同 G1 一样，基于 Region 的堆内存布局，同样 有着用于存放大对象的 Humongous Region，默认的回收策略也同样是优先处理回收价值最大的 
Region
		- 与 G1 不同之处

			- 支持并发的整理算法
			- 默认不使用分代收集
			- 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为「连接矩阵」

		- 运作过程

			- 初始标记

				- Stop The World
				- 首先标记与 GC Roots 直接关联的对象

			- 并发标记

				- 遍历对象图，标记出全部可达的对象，这个阶段 是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。

			- 最终标记

				- 处理剩余的 SATB(原始快照)扫描，并在这个阶段统计出回收价值最高的 Region。

			- 并发清理

				- 清理那些整个区域内连一个存活对象都没有找到 的 Region

			- 并发回收

				- 与 G1 的核心差异，把回收集里面的存活对象先复制一份到其他未被使用的 Region 之中，通过「读屏障」解决与用户线程并发的问题

			- 初始引用更新

				- 把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新
				- 初始引用更新时间很短，会产生一个非常短暂的 停顿。

			- 并发引用更新

				- 真正开始进行引用更新操作，这个阶段是与用户 线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。
				- 按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。

			- 最终引用更新

				- 解决了堆中的引用更新后，还要修正存在于 GC Roots 中的引用。这个阶段是 Shenandoah 的最后一次停顿，停顿时间只与 GC Roots 的数量相关。

			- 并发清理

				- 调用一次并发清理过程来回收这些 Region 的内存空间，供以后新对象分配使用。

	- ZGC 收集器

- 选择合适的垃圾收集器
- 实战：内存分配与回收策略

### 4、虚拟机性能监控、故障处理工具

### 5、调优案例分析与实战

## 三、虚拟机执行子系统

## 四、程序编译与代码优化

## 五、高效并发

### 十三、线程安全与锁优化

- 概述
- 线程安全

	- 线程安全的定义

		- 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

	- Java 语言中的线程安全

		- 不可变

			- final + 基本数据类型，一定是线程安全的（没有发生 this 逃逸）
			- final + 对象需要对象自行保证其行为不会对其状态产生任何影响

				- 对象里面带有状态的变量都声明为 final

		- 绝对线程安全

			- 如定义所属就是「绝对线程安全」
			- 在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全

		- 相对线程安全

			- 通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

		- 线程兼容

			- 指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。

		- 线程对立

			- 线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。
			- suspend()
			- resume()
			- System.setIn()
			- Sytem.setOut()
			- System.runFinalizersOnExit()

	- 线程安全的实现方法

		- 互斥同步

			- 同步

				- 在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用

			- 互斥是实现同步的一种手段

				- 临界区
				- 互斥量
				- 信号量

			- synchronized 关键字

				- synchronized 关键字经过 Javaca 编译之后，会在同步块的前后分别形成monitorenter 和 monitorexit 这两个字节码指令。
				- 这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。

					- 如果Java源码中的 synchronized 明确指定了对象参数，那就以这个对象的引用作 为reference
					- 如果没有明确指定，将根据 synchronized 修饰的方法类型（如实例方法或类方法）来决定是取代码所在的对象实例还是取类型对应的 Class 对象来作为线程要特有的锁

				- 同步块也是可重入锁

					- 被 synchronized 修饰的同步块对同一条线程来说是可重入的。同一线程反复进入同步块不会出现自己把自己锁死的情况。
					- 被 synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。

				- 局限

					- 无法像处理某些数据库中的锁那样，强制己获取锁的线程释放锁
					- 无法强制正在等待锁的线程中断等待或超时退出。
					- 从执行成本的角度看，持有锁是一个重量级的操作。

						- 主流 Java 虚拟机实现中，Java 的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转 换需要耗费很多的处理器时间。

			- 重入锁 ReentrantLock

				- 解决了 synchronized 的局限

					- 等待可中断

						- 持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

					- 可实现公平锁

						- 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
						- 不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显影响吞吐量。

					- 锁可以绑定多个条件

						- 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象

		- 非阻塞同步

			- CAS

				- 当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但是，不管是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。

			- ABA 问题

				- 如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为 A 值，如果在这段期间它的值曾经被改成B，后来又被改回为A，那 CAS 操作就会误认为它从来没有被改变过。

					- JUC 使用 AtomicStampedReference 通过控制变量值的版本保证 CAS，但是比较鸡肋，不如直接使用互斥同步

		- 无同步方案

			- 可重入代码（纯代码）

				- ThreadLocal

					- ThreadLocal 是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用 ThreadLocal 来维护变量时, ThreadLocal 会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。 
					- Thread 如何实现线程隔离

						- ThreadLocalMap，key 就是 ThreadLocal 变量名（当前线程），value 为对应的对象
						- 其实就是用了 Map 的数据结构给当前线程缓存了, 要使用的时候就从本线程的 threadLocals 对象中获取就可以了，key 就是当前线程。
						- ThreadLocalMap的Entry实现继承了WeakReference<ThreadLocal<?>>
						- 因为 ThreadLocal 需要用 final static 修饰，所以保持强引用，但是内部 map 又是个弱引用，不会释放，造成内存泄漏

							- ThreadLocal 提供了一个清除线程中对象的方法, 即 remove，其实内部实现就是调用 ThreadLocalMap 的 remove 方法

- 锁优化

	- 自旋锁与自适应锁
	- 锁清除
	- 锁粗化
	- 轻量级锁

		- https://pic.imgdb.cn/item/624f01e2239250f7c592109e.jpg

	- 偏向锁
	- 总述

		- 一个锁对象刚刚开始创建的时候，没有任何线程来访问它，它是可偏向的，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问他的时候，它会偏向这个线程。此时线程状态为无锁状态，锁标志位为 01

			- 无锁

		- 当一个线程（线程 A）来获取锁的时，会首先检查所标志位，此时锁标志位为 01，然后检查是否为偏向锁，此时不为偏向锁，所以当前线程会修改对象头状态为偏向锁，同时将对象头中的 ThreadID 改成自己的 Thread ID

			- 偏向

		- 如果再有一个线程（线程 B）过来，此时锁状态为偏向锁，该线程会检查 Mark Word 中记录的线程 ID 是否为自己的线程 ID，如果是，则获取偏向锁，执行同步代码块。如果不是，则利用 CAS 尝试替换 Mark Word 中的 Thread ID，成功，表示该线程（线程 B）获取偏向锁，执行同步代码块
		- 如果线程 B 获取偏向锁失败，则表明当前环境存在锁竞争情况，则执行偏向锁的撤销工作

			- 检查线程 A 是否还活着

				- 线程 A 死了的话线程 B  自己重新获取偏向锁
				- 线程 A 如果没死，就继续检查线程 A 是否还需要偏向锁，如果依然需要，升级为轻量级锁

		- 轻量级锁的释放成功，则表示没有发生竞争，直接释放。如果失败，表明锁对象存在竞争关系，这时会轻量级锁会升级为重量级锁，然后释放锁，唤醒被挂起的线程，开始新一轮锁竞争，此后就是重量级锁

