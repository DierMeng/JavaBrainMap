# Redis

## 一、Redis 通信协议（RESP）

### 特征

- TCP 层
- 是二进制安全的
- 基于请求 - 响应模式
- 简单、易懂

### 传输结构

- 单行字符串，第一个字节为 +
- 错误消息，第一个字节为 -
- 整型数字，第一个字节为 :，后跟整数的字符串
- 多行字符串，第一个字节为 $，后跟字符串的长度
- 数组，第一个字节为 *，后跟跟着数组的长度

## https://pic.imgdb.cn/item/624e8ebd239250f7c59cd4f8.png
二、Redis 线程模型

### 多个 Socket

### IO 多路复用程序

### 文件事件分派器

- 连接应答处理器

	- 客户端要连接 Redis

- 命令请求处理器

	- 客户端要写数据到 Redis（读、写请求命令）

- 命令回复处理器

	- 客户端要从 Redis 读数据

### 事件处理器

- AE_READABLE

	- 当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件

- AE_WRITABLE

	- 当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE 事件。

### 多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。

- https://pic.imgdb.cn/item/624e8fcf239250f7c59ef089.png

## 三、Redis 之 pipeline

### Redis 的性能瓶颈主要在客户端和服务端之间的网络性能

### pipeline

- 将一组 Redis 命令进行组装，通过一次 RTT 传输给 Redis，同时再将这组命令的执行结果按照顺序返回给客户端 。

## 四、Redis 持久化

### RDB

- 快照存储持久化方式，具体就是将 Redis 某一时刻的内存数据全量保存到硬盘的文件当中，默认保存的文件名为 dump.rdb，而在 Redis 服务器启动时，会重新加载 dump.rdb 文件的数据到内存当中恢复数据。

	- RDB 优劣势以及与 AOF 的比较

		- 与 AOF 方式相比，通过 rdb 文件恢复数据比较快。
		- rdb 文件非常紧凑，适合于数据备份。
		- 通过 RDB 进行数据备，由于使用子进程生成，所以对 Redis 服务器性能影响较小。
		- 如果服务器宕机的话，采用 RDB 的方式会造成某个时段内数据的丢失
		- 使用 save 命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。
		- 由于 AOF 的优先级更高，因此当 AOF 开启时，Redis 会优先载入 AOF 文件来恢复数据
		- 只有当 AOF 关闭时，才会在 Redis 服务器启动时检测 RDB 文件，并自动载入，载入过程中 Redis 处于阻塞状态

	- 触发条件

		- 手动触发

			- save

				- 阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在 Redis 服务器阻塞期间，服务器不能处理任何命令请求。
				- 线上环境要杜绝 save 的使用

			- bgsave

				- 创建一个子进程，由子进程来负责创建 RDB 文件，父进程（即 Redis 主进程）则继续处理请求。

		- 自动触发

			- save m n

				- 在配置文件中通过「save m n」，指定当 m 秒内发生 n 次变化时，触发 bgsave 操作。

			- 在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行 bgsave 命令，并将 rdb 文件发送给从节点
			- 执行 shutdown 命令时，自动执行 rdb 持久化

### AOF（主流）

- 记录客户端对服务器的每一次写操作命令，并将这些写操作以 Redis 协议追加保存到以后缀为 aof 文件末尾，在 Redis 服务器重启时，会加载并运行 aof 文件的命令，以达到恢复数据的目的。

	- AOF 执行流程

		- 命令追加（append）

			- 将 Redis 的写命令追加到缓冲区 aof_buf，避免硬盘 IO 成为 Redis 负载的瓶颈。

		- 文件写入（write）、文件同步（sync）

			- 根据不同的同步策略将 aof_buf 中的内容同步到硬盘
			- 策略

				- no

					- 命令写入 aof_buf 后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒

				- always

					- 客户端的每一个写操作都保存到 aof 文件当中，这种策略很安全，但是每个写请注都有 IO 操作，所以也很慢。

				- everysec（默认配置）

					- 默认写入策略，每秒写入一次 aof 文件，因此，最多可能会丢失 1s 的数据。

		- 文件重写（rewrite）

			- 定期重写 AOF 文件，达到压缩的目的
			- 把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件，所以不会对旧的 AOF 文件进行任何读取、写入操作
			- 触发条件

				- 手动触发

					- 直接调用 bgrewriteaof 命令

				- 自动触发

					- 根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数，以及 aof_current_size 和 aof_base_size 状态确定触发时机

## 五、redis-cli 命令相关

### info XXX

- info memory

	- 查看内存使用情况

		- used_memory

			- Redis 分配器分配的内存总量（单位是字节）

		- used_memory_rss

			- Redis 进程占据操作系统的内存（单位是字节）

		- mem_fragmentation_ratio

			- 内存碎片比率，该值是 used_memory_rss / used_memory 的比值。1.03 是比较正常的值

				- > 1

					- 内存碎片多，内存浪费严重
					- 考虑重启 redis 服务，在内存中对数据进行重排，减少内存碎片

				- < 1

					- 内存不足，部分数据使用了虚拟内存，访问速度可能会变得很慢

		- mem_allocator

			- Redis 使用的内存分配器，在编译时指定

				- libc 
				- jemalloc（默认）

					- 在减小内存碎片方面做的相对比较好
					- jemalloc 在 64 位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当 Redis 存储数据时，会选择大小最合适的内存块进行存储。

				- tcmalloc

- info 命令可以显示 redis 服务器的许多信息

	- 服务器基本信息

		- info server

	- CPU
	- 内存
	- 查看持久化相关状态

		- info Persistence

			- aof_enabled

				- AOF 是否开启

			- aof_last_rewrite_time_sec

				- 上次文件重写执行时间（s），用于发现文件重写是否耗时过长

			- aof_last_bgrewrite_status

				- 上次 bgrewrite 执行结果

			- aof_delayed_fsync

				- AOF 追加阻塞情况的统计

			- rdb_last_bgsave_status

				- 上次 bgsave 执行结果

			- rdb_last_bgsave_time_sec

				- 上次 bgsave 执行时间（s）

		- info stats

			- latest_fork_usec

				- 上次 fork 耗时

	- 客户端连接信息

### type key[XXX]

- 读取 RedisObject 的 type 字段获得对象 key 对应 Value 的类型

### object 相关命令

- object encoding key[XXX]

	- 查看对象 key 对应 Value 采用的编码方式

- object idletime key[XXX]

	- 显示当前 key 对应 Value 的空转时间（单位是秒）。空转时间就是该 Value 最后一次呗命令程序访问的时间.object idletime 命令不改变对象的 lru 值。

- object refcount key[XXX]

	- 查看 key 对应 value 的共享对象引用次数

### 发布与订阅

- SUBSCRIBE channel [channel …] 
-  UNSUBSCRIBE [channel [channel …]] 
-  PUBLISH channel message

### 事务相关命令

- discard

	- 取消事务，放弃执行事务块内的所有命令。
	- 如果正在使用 WATCH 命令监视某个或某些 key，那么取消所有监视，等同于执行命令 UNWATCH 

### 线上 Redis 禁止使用 Keys 正则匹配操作

## 六、内存划分

### 数据

- 数据是最主要的部分
- 占用的内存会统计在 used_memory 中

### 进程本身运行需要的内存

- Redis 主进程本身运行肯定需要占用内存，如代码、常量池等等
- 这部分内存不是由 jemalloc 内存分配器分配，因此不会统计在 used_memory 中。
- 除了主进程外，Redis 创建的子进程运行也会占用内存，如 Redis 执行 AOF、RDB

### 缓冲内存

- 客户端缓冲区

	- 存储客户端连接的输入输出缓冲

- 复制积压缓冲区

	- 用于部分复制功能

- AOF 缓冲区

	- 进行 AOF 重写时，保存最近的写入命令

- 内存由 jemalloc 内存分配器分配，因此会统计在 used_memory 中。

### 内存碎片

- Redis 在分配、回收物理内存过程中产生的
- 内存碎片不会统计在 used_memory 中。

### 优化内存占用

- 利用 jemalloc（内存分配器）特性进行优化
- 使用整型/长整型
- 共享对象

	- 可以减少对象的创建，节省内存空间

- 避免过度设计
- 设置合理的数据回收策略

## 七、基础数据结构（key 都是字符串，value 对应着不同的数据结构）

### string（字符串）

- 缓存用户信息（JSON 序列化）、计数
- 预分配冗余空间的形式设计，每次扩容 1M，最多 512M，类似于 Java 中的 ArrayList 的设计

### list（列表）

- 常用于做异步队列
- 相当于 Java 中的链表（LinkedList），插入删除块，索引慢，弹出最后一个元素的时候数据结构自动被删除。
- ziplist（快速列表）

	- 列表元素较少的情况是使用一块连续的内存存储加速元素的访问
	- 元素量大的时候 ziplist 会与链表结合组成 quicklist，将 ziplist 使用双向指针串联起来使用

- 最多存储 2^32 - 1 个元素，可以充当数组、队列、栈使用

### hash（字典）

- 类似 Java 中的 hashMap，采用数组加链表的形式
- 当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。
- 一般也用于存储用户信息，可以针对字段做自定义单独存储
- 存储消耗相对于要高于字符串

### set（集合）

- 相当于 Java 里面的 HashSet，键值对无序但唯一
- 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。
- 常用于存储活动中奖的用户 ID
- 最多存储 2^32 - 1 个元素

### zset（有序列表）

- 类似于 Java 中的 SortedSet 和 HashMap 的结合体
- zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。
- 常用于存储粉丝列表，比如 value 代表粉丝 ID，score 代表关注时间，从而可以按照时间排序
- 也可用于存储学生成绩，value 代表学生 ID，score 代表考试成绩，从而按照成绩排名
- 跳跃列表

	- zset 的内部排序功能通过「跳跃列表实现」
	- 类似于层级制，或者你可以想象为这张思维导图的样子
	- 一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

- 有序集合为每个元素设置一个分数（score）作为排序依据
- 底层实现

	- 有序集合对象的编码可以是 ziplist 或者 skiplist
	- 使用 ziplist 编码的条件（同时满足）

		- 元素数量小于 128 个
		- 所有 member 的长度都小于 64 字节

	- ziplist

		- 使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。
		- ziplist 内的集合元素按 score 从小到大排序，score 较小的排在表头位置。

	- skiplist

		- 底层是一个命名为 zset 的结构体，而一个 zset 结构同时包含一个字典和一个跳跃表。
		- 跳跃表按 score 从小到大保存所有集合元素。
		- 字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。
		- 虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。
		- 跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为 O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供 O(logN) 的时间复杂度。

## 十四、如何排查 Redis 性能问题

### 业务服务器到 Redis 服务器之间的网络存在问题

### Redis 本身存在问题

- latency 命令测试 Redis 的基准性能
- Redis 的慢日志（默认 20 毫秒），慢日志会记录对应的比较慢的执行命令以及对应的时间节点
- 是否存在复杂的命令才做
- 检查 bigkey

	- 如果一个 key 写入的 value 非常大，那么 Redis 在分配内存时就会比较耗时。同样的，当删除这个 key 时，释放内存也会比较耗时，这种类型的 key 一般称之为 bigkey。
	- 使用 bigkey 命令查询对应的 bigkey

- 集中过期

	- Redis 数据过期处理方式

		- 被动过期

			- 只有当访问某个 key 时，才判断这个 key 是否已过期，如果已过期，则从实例中删除

		- 主动过期

			- edis 内部维护了一个定时任务，默认每隔 100 毫秒（1秒10次）就会从全局的过期哈希表中随机取出 20 个 key，然后删除其中过期的 key，如果过期 key 的比例超过了 25%，则继续重复此过程，直到过期 key 的比例下降到 25% 以下，或者这次任务的执行耗时超过了 25 毫秒，才会退出循环
			- 这个主动过期 key 的定时任务，是在 Redis 主线程中执行的。
			- 如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个过期任务执行结束，Redis 才可以服务这个客户端请求。

				- 此种情况下应用访问 Redis 延时变大

	- 解决方案

		- 集中过期 key 增加一个随机过期时间，把集中过期的时间打散，降低 Redis 清理过期 key 的压力
		- 开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程

- 实例内存达到上限
- fork 耗时严重

	- 当 Redis 开启了后台 RDB 和 AOF rewrite 后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。
	- 主进程创建子进程，会调用操作系统提供的 fork 函数。fork 在执行过程中，主进程需要拷贝自己的内存页表给子进程，如果这个实例很大，那么这个拷贝的过程也会比较耗时。

- 开启内存大页
- aof 刷盘机制不合理
- 绑定CPU
- 使用Swap
- 碎片整理
- 网络带宽过载

## 十三、缓存简介

###  缓存模式

- Cache-Aside

	- 读操作

		- 程序接收数据查询的请求
		- 程序检查要查询的数据是否在缓存上

			- 如果存在，从缓存上查询出来
			- 如果不存在，从数据库中检索数据并存入缓存中

		- 程序返回要查询的数据

	- 更新操作

		- 使缓存失效

			- 当请求需要更新数据库数据的时候，缓存中的值需要被删除掉,下次数据读取的时候会存进缓存

		- 缓存更新

			- 在数据库更新的时候被更新

- Read-Through

	- 直接从缓存中读数据，该场景下是缓存去决定从哪查询数据。

- Write-Through

	- 所有的写操作都经过缓存，每次我们向缓存中写数据的时候，缓存会把数据持久化到对应的数据库中去，且这两个操作都在一个事务中完成。

### 缓存击穿

- 概念：请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。
- 问题：黑客拿数据库中不存在的字段值进行大量的请求导致服务宕机
- 解决方式

	- 缓存控制，定期设置过期时间
	- 哈希过滤
	- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
	- 用异步更新策略，无论 key 是否取到值，都直接返回。value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
	- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。

### 缓存穿透

- 概念：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去
- 问题：造成数据库瞬间请求过载，压力陡增，服务宕机
- 解决方式

	- 请求线程加锁，或者数据库查询加锁
	- 数据返回记录之后作为缓存承载给其他请求

### 缓存雪崩

- 概念：缓存服务宕机，导致大量请求直接打进数据库造成服务宕机
- 问题：数据库由于请求量过大而崩溃 
- 解决方式

	- 缓存集群
	- 如果是微服务，可以设置网关限流
	- 使用缓存技术中的本地缓存（缓存在硬盘中）
	- 设置 Redis 持久化，服务重启之后自动加载数据缓存到 Redis 中
	- 给缓存的失效时间，加上一个随机值，避免集体失效。

### 缓存预热

- 系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题
- 缓存预热设置方案

	- 直接写个缓存刷新页面，上线时手工操作下
	- 数据量不大，可以在项目启动的时候自动进行加载
	- 定时刷新缓存

### 缓存更新策略

- 除了 Redis 自有的缓存数据淘汰策略「数据淘汰策略（lru、随机、将要过期、不淘汰）」,还可以根据业务需求自定义缓存淘汰策略

	- 定时去清理过期的缓存

		- 维护大量缓存的 key 是比较麻烦的

	- 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

		- 每次用户请求过来都要判断缓存失效，逻辑相对比较复杂

- 四种缓存更新策略

	- 先更新缓存，再更新数据库（不推荐使用）

		- 很少的业务场景会去使用这种策略

	- 先更新数据库，再更新缓存（不推荐使用）

		- 线程安全

			- 同时有请求 A 和请求 B 进行更新操作，会出现线程 A 更新了数据库，线程 B 更新了数据库，线程 B 更新了缓存，线程 A 更新了缓存，可是按道理请求 A 更新缓存应该比请求 B 更新缓存早才对

		- 业务场景

			- 如果写多读少的业务场景，采用这种方案就会导致数据压根还没读到，缓存就被频繁的更新，浪费性能。
			- 如果写入数据库的值并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，是浪费性能的。这种情况下删除缓存更为合适。

	- 先删除缓存，再更新数据库（会导致数据库与缓存不一致）

		- 如果不采用给缓存设置过期时间策略，出现不一致时缓存永远都是脏数据。

			- 请求 A 进行更新操作
请求 B 进行查询操作
请求 A 进行写操作，删除缓存
请求 B 查询发现缓存不存在
请求 B 去数据库查询得到旧值
请求 B 将旧值写入缓存
请求 A 将新值写入数据库

		- 解决方案

			- 延时双删策略（将一定时间内的脏数据删除，该方案也适合 MySQL 读写分离架构下主从不及时产生脏数据缓存的情况）

				- 先淘汰缓存
				- 再写数据库
				- 延时一定时间
				- 再次淘汰缓存

		- 产生脏数据的概率较大，查询得到旧数据，多数不建议这样做

	- 先更新数据库，再删除缓存

		- 应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
		- 存在的并发问题（缓存脏数据）

			- 请求 A 做查询操作
请求 B 做更新操作
缓存刚好失效
请求 A 查询数据库，得一个旧值
请求 B 将新值写入数据库
请求 B 删除缓存
请求 A 将查到的旧值写入缓存

				- 发生概率基本可以忽略，因为对于数据库来讲读快写慢

		- 脏数据产生概率低，但是会出现一致性异步问题，但是问题不大，数据更新之后更新缓存即可。多数情况建议选择此种方式

	- 如何解决后两种缓存脏数据的问题

		- 设置缓存有效时间
		- 双删缓存第二次删除缓存失败的解决方案（重试机制）

			- 消息队列，将需要删除的 key 发送至消息队列
			- 订阅数据库的 binlog

### 缓存降级

- 当访问量剧增、服务出现问题（响应时间慢、不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务
- 最终目的是保证核心服务可用，即使是有损的
- 可以参考日志级别进行降级预案

### 热点数据集中失效

- 概念：缓存都有失效时间，那么作为热点数据失效的瞬间也会有大量的请求直接涌入到数据库
- 解决方式

	- 不同的热点数据设置不同的失效时间
	- 互斥锁

## 十二、Redis 锁

### 客户端可以使用同步机制

### 服务器端

- setnx

### 分布式锁

- 利用 setnx+expire 命令

	- SETNX 是 SET IF NOT Exists 的缩写，即 setnx key value，将 key 设置为 value，当键不存在时，才能成功，若键存在，什么也不做，成功返回 1，失败返回 0 。
	- 因为 setnx + expire 命令过程中不具有原子性，所以不推荐直接使用
	- 可以优化为使用 Lua 脚本将两个命令封装为一个操作进行使用，不过依然不推荐

-  使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (推荐)

	- EX seconds: 设定过期时间，单位为秒
	- PX milliseconds: 设定过期时间，单位为毫秒
	- NX: 仅当key不存在时设置值
	- XX: 仅当key存在时设置值

- Redlock算法 与 Redisson 实现

	- 主要解决上一条锁在集群、多节点的情况下锁失效的问题
	- 获取当前时间
	- 发起请求，并设置超时时间，超时时间要小于锁的过期时间
	- 使用当前时间减掉开始获取锁的时间得到获取锁所使用的时间，这个时间要满足小于锁失败的时间并且实例当中超过一半的实例都获取到了锁才算成功
	- 如果锁获取失败，Redis 所有实例进行解锁，及时某些实例没有加锁成功

## 十一、数据淘汰策略（lru、随机、将要过期、不淘汰）

### volatile-lru

- 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

### volatile-ttl

- 从已设置过期时间的数据集中挑选将要过期的数据淘汰

### volatile-random

- 从已设置过期时间的数据集中任意选择数据淘汰

### allkeys-lru

- 从数据集中挑选最近最少使用的数据淘汰

### allkeys-random

- 从数据集中任意选择数据淘汰

### no-enviction

- 禁止驱逐数据

## 十、数据模型

### dictEntry

- 每个键值对都会有一个 dictEntry，里面存储了指向 Key 和 Value 的指针；
- next 指向下一个 dictEntry，与本 Key-Value 无关。

### Key

- Key 并不是直接以字符串存储，而是存储在 SDS 结构中
- SDS（Simple Dynamic String，简单动态字符串）

	- len

		- buf 已经使用的长度

	- free

		- buf 未使用的长度

	- buf[]

		- 字节数组，用来存储字符串
		- buf.length = free + len + 1

### redisObject

- Value 既不是直接以字符串存储，也不是像 Key 一样直接存储在 SDS 中，而是存储在 redisObject 中
- 不论 Value 是 5 种类型的哪一种，都是通过 redisObject 来存储的
- redisObject 中的 type 字段指明了 Value 对象的类型，ptr 字段则指向对象所在的地址
- 不过字符串对象虽然经过了 redisObject 的包装，但仍然需要通过 SDS 存储
- 底层构成及细节

	- type

		- 表示对象的类型，占4个 bit （比特）

	- encoding

		- 表示对象的内部编码，占4个 bit （比特）
		- string

			- int（8 字节）

				- 使用整数值实现的字符串对象
				- 当 int 数据不再是整数，或大小超过了 long 的范围时，自动转化为 raw。

			- embstr（<= 39字节）

				- 使用 embstr 编码的 SDS 实现的字符串对象
				- 只分配一次内存空间
				- 实现为「只读」

					- 对 embstr 对象进行修改时，都会先转化为 raw 再进行修改，所以只要是修改 embstr 对象，修改后的对象一定是 raw 的，无论是否达到了 39 个字节

			- raw（> 39 字节的字符串）

				- 使用 SDS 实现的字符串对象
				- 需要分配两次内存空间

			- 为啥以 39 作为区分？

				- redisObject 的长度是 16 字节
				- sds 的长度是 9+
				- jemalloc 正好可以分配 64 字节的内存单元

		- list

			- 压缩列表（ziplist）

				- 由一系列特殊编码的连续内存块组成的顺序型数据结构
				- ziplist 是一个双向链表，目的是为了提供存储效率
				- 用于存储字符串或者整数。当一个列表键或者哈希键值对包含少量的元素项，且每项要么是小整数型，要么就是长度比较短的字符串时，Redis 就会使用 ziplist 来做他们的底层实现。
				- 使用满足条件

					- 列表中元素数量小于 512 个
					- 列表中所有字符串对象都不足 64 字节（便于统一分配每个节点的长度）

			- 双端链表（linkedlist）

				- 使用双端链表实现的列表对象

		- hash

			- 压缩列表（ziplist）

				- 使用满足条件

					- 哈希中元素数量小于 512 个
					- 哈希中所有键值对的键和值字符串长度都小于 64 字节

			- ht

				- 使用字典实现的哈希对象

		- set

			- intset

				- 使用整数集合实现的集合对象

					- 当集合元素不大于设定值并且元素都是整数时，就会用 intset 作为 Set 的底层数据结构。
					- 特点

						- 元素类型只能为数字
						- 元素有三种类型：int16_t、int32_t、int64_t
						- 元素有序且不可重复
						- 和 SDS 一样，intset 也是内存连续的，就像数组一样

				- 使用满足条件

					- 集合中元素数量小于 512 个
					- 集合中所有元素都是整数值

			- ht

				- 使用字典实现的集合对象

		- zset

			- 压缩列表（ziplist）

				- 使用压缩列表实现的列表对象
				- 使用满足条件

					- 有序集合中元素数量小于 128 个
					- 有序集合中所有成员长度都不足 64 字节

			- skiplist

				- 可以进行二分查找的有序链表

					- 由很多层结构组成，level是通过一定的概率随机产生的
					- 每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序
					- 最底层(Level 1)的链表包含所有元素
					- 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现
					- 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素

				- 使用跳跃表和字典实现的有序集合对象

		- 编码转换在 Redis 写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。

	- lru

		- 对象最后一次被命令程序访问的时间

	- refcount

		- 记录的是对象被引用的次数，类型为整型
		- 主要用于对象的引用计数和内存回收
		- 创建新对象时，refcount 初始化为 1；当有新程序使用该对象时，refcount 加 1；当对象不再被一个新程序使用时，refcount 减 1；当 refcount 变为 0 时，对象占用的内存会被释放。
		- 被多次使用的对象（refcount > 1），称为共享对象，仅支持整数值的字符串对象

			- Redis 服务器在初始化时，会创建 10000个 字符串对象，值分别是 0~9999 的整数值；当 Redis 需要使用值为 0~9999 的字符串对象时，可以直接使用这些共享对象。

	- ptr

		- 指针，指向具体的数据

- 一个 redisObject 对象的大小为16字节（byte）

### 以后依靠 jemalloc（内存分配器）进行分配

## 九、集群方案

### Redis 高可用方案

- 持久化

	- 见左侧「Redis 持久化」

- 主从复制（即读写分离）

	- 作用

		- 数据冗余

			- 实现数据的热备份，属于持久化之外的一种数据冗余方式

		- 故障恢复

			- 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复
			- 也就是服务冗余的一种方式

		- 负载均衡

			- 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务

		- 高可用基石

			- 哨兵模式和集群能够实施的基础

	- 如何开启主从复制（只需要从「从节点」开启复制）？

		- 配置文件

			- 在从服务器的配置文件中加入：slaveof <masterip> <masterport>

		- 启动命令

			- redis-server启动命令后加入 --slaveof <masterip> <masterport>

		- 客户端命令

			- 通过客户端执行命令：slaveof <masterip> <masterport>，当前实例即为从节点

	- 主从复制实现原理

		- 连接建立阶段

			- 在主从节点之间建立连接，为数据同步做好准备。

				- 保存主节点信息
				- 建立 socket 连接
				- 发送 ping 命令
				- 身份验证
				- 发送从节点端口信息

		- 数据同步阶段

			- 从节点向主节点发送 psync 命令，开始同步。
			- 复制类型

				- 全量复制

					- 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。

				- 部分复制

					- 用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。
					- 三个概念

						- 复制偏移量

							- 主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数

						- 复制积压缓冲区

							- 由主节点维护的、固定长度的、先进先出（FIFO）队列，默认大小 1MB
							- 备份主节点最近发送给从节点的数据。
							- 无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。
							- bgsave 生成 RDB 文件、RDB 文件由主节点发往从节点、从节点清空老数据并载入 RDB 文件中的数据。

						- 服务器运行 ID

							- 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个 runid 保存起来
							- 当断线重连时，从节点会将这个 runid 发送给主节点；主节点根据 runid 判断能否进行部分复制：

			- psync 复制命令

				- 从节点根据当前状态决定如何调用 psync

					- 如果没有执行过 slaveof 或者最近执行了 slaveof no one 命令，会向主节点发送「psync ? -1」命令，请求全量复制
					- 如果执行过 slaveof 命令，会发送「psync <runid> <offset>」命令请求部分复制

				- 主节点根据收到的 psync 命令以及当前服务器的状态决定执行全量复制还是部分复制

					- 如果 Redis 版本低于 2.8，直接执行全量复制
					- 如果版本符合部分复制的要求，并且接收到从节点发来的 runid 与当前自身 runid 相同，复制挤压缓冲区也包含从节点发送过来的 offset，则进行部分复制
					- 如果 runid 不同或者 offset 已经在复制挤压缓冲区中不完整，则发起全量复制

		- 命令传播阶段

			- 主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。
			- 主从心跳机制

				- PING

					- 每隔指定的时间，主节点会向从节点发送PING命令，这个 PING 命令的作用，主要是为了让从节点进行超时判断。

				- REPLCONF ACK

					- 从节点会向主节点发送 REPLCONF ACK 命令，频率是每秒 1 次

						- 实时监测主从节点网络状态
						- 检测命令丢失
						- 辅助保证从节点的数量和延迟

	- 主从复制、读写分离的普遍问题

		- 读写分离

			- 延迟与不一致
			- 数据过期

				- 惰性删除

					- 服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。

				- 定期删除

					- 服务器执行定时任务删除过期数据

				- Redis 3.2 版本以后，从节点在读取数据时，增加了对数据是否过期的判断

			- 故障切换

		- 主从复制

			-  复制超时

				- 主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源
				- 从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致

			- 复制中断

				- 复制缓冲区溢出

		- 故障恢复无法自动化
		- 写操作无法负载均衡
		- 存储能力受到单机的限制

- 哨兵模式

	- 见下方「哨兵模式（Sentinel）」

- 集群

### 官方 redis-cluster 路由查询

- 优势及作用

	- 所有功能都集成在 redis cluster 中，路由分片、拓扑信息的存储、探活都在 redis cluster 中实现；各实例间通过 gossip 通信；这样的好处是简单，依赖的组件少
	- 数据分区（最核心的功能）

		- 将数据分散到多个节点，突破了 Redis 单机内存大小的限制，存储容量大大增加
		- 每个主节点都可以对外提供读服务和写服务，提高集群的响应能力
		- 关于 Redis 分区参考上面「Redis 分区（配合集群使用）」

	- 高可用

- 劣势：需要支持更大的规模时，由于使用 gossip 协议导致协议之间的通信消耗太大，redis cluster 不再合适；
- 
- 服务器端分片技术
- Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。

### twemproxy 代理、nutcracker

- 原理：twemproxy 处于客户端和服务器的中间，将客户端发来的请求，进行一定的处理后（sharding），再转发给后端真正的redis服务器。
- 客户端不直接访问 redis 服务器，而是通过 twemproxy 代理中间件间接访问。降低了客户端直连后端服务器的连接数量，并且支持服务器集群水平扩展。
- 中间件做分片的技术
- 

	- 

		- 

### codis

- 特点

	- 分片算法：基于 slot hash 桶；
	- 分片实例之间相互独立，每组一个 master 实例和多个 slave；
	- 路由信息存放到第三方存储组件，如 zookeeper 或 etcd
	- 旁路组件探活

- 划分了 1024 个 slot， slots 信息在 proxy 层感知； redis 进程中维护本实例上的所有 ke y的一个 slot map；
- 图片可拖拽放大

### 哨兵模式（Sentinel）

- 解决主节点故障恢复的自动化问题，进一步提高系统的高可用性。在主从复制的基础上解决了「自动化的故障恢复」这个问题

	- 自动完成故障发现和故障转移并通知应用方，从而实现真正的高可用的分布式架构 。

- 原理：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。
- https://pic.imgdb.cn/item/624e95f4239250f7c5ab0941.png
至少需要 3 个实例，来保证自己的健壮性

	- https://pic.imgdb.cn/item/624e95f4239250f7c5ab093d.png

		- https://pic.imgdb.cn/item/624e95f4239250f7c5ab093a.png

- 功能及架构

	- 哨兵功能

		- 监控

			- 不断地检查主节点和从节点是否运作正常

		- 自动故障转移（核心功能）

			- 主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。

		- 配置提供者

			- 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。

		- 通知

			- 哨兵可以将故障转移的结果发送给客户端。

	- 架构

		- 哨兵节点

			- 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 redis 节点，不存储数据。

		- 数据节点

			- 主节点和从节点都是数据节点。

### 客户端分片，一致性哈希

- 关于一致性 Hash 算法，可以参考一下老四的这片文章《Java 十道由浅入深的笔面试题第四期》。http://www.glorze.com/1476.html

	- 构造一个 0 ~ 2^32-1 大小的环。

		- 在 Redis 中是 16384 个

			- 如果槽位为 65536，发送心跳信息的消息头达 8k，发送的心跳包过于庞大。
			- redis 的集群主节点数量基本不可能超过 1000 个。
			- 槽位越小，节点少的情况下，压缩率高

	- 服务节点经过 hash 之后将自身存放到环中的下标中。
	- 客户端根据自身的某些数据 hash 之后也定位到这个环中。
	- 通过顺时针找到离他最近的一个节点，也就是这次路由的服务节点。
	- 考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点。

## 八、Redis 分区（配合集群使用）

### 分区的概念

- 分区就是将数据分割到多个 Redis 实例中的一个过程，因此每个实例仅仅包含部分键（key）

### 分区的优势

- 利用多台机器的内存构建一个更大数据库
- 可以在多核和多计算机之间弹性扩展计算能力，也可以在多计算机和网络适配器之间弹性扩展网络带宽

### 分区的劣势

- 不支持多个键的操作（可以曲线、间接实现）
- 不支持多个键的事务
- 不能使用单个大键对数据集进行分片
- 数据的处理会变得复杂，比如必须处理多个 RDB 和 AOF 文件
- 添加和删除节点也会变得复杂

### 分区基础、方式

- 范围分区
- 哈希分区（取余）
- 一致性哈希
- 带虚拟节点的一致性哈希分区（Redis 集群默认采用的方案）

### 分区不同的实现方式

- 客户端分区

	- 客户端直接选择正确节点读写指定键

- 代理辅助分区（Twemproxy）

	- 客户端通过 Redis 协议把请求发送给代理，而不是直接发送给真正的 Redis 实例服务器。
	- 代理根据请求根据配置分区策略发送到正确的 Redis 实例上，并返回给客户端。

- 查询路由

	- 把一个请求发送给一个随机的实例，这时实例会把该查询转发给正确的节点。

### 分区的使用

- Redis 如果作为可伸缩缓存服务器来使用，那么用一致性哈希比较简单
- Redis 被作为数据持久化服务器，需要提供节点和键值的固定映射，还有节点数目必须是固定的，不能改变。(使用集群解决问题)

