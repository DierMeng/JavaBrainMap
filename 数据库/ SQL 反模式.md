#  SQL 反模式

## 1、乱穿马路

### 通常使用逗号分隔的列表来避免在多对多的关系中创建交叉表，这种设计方式定义为一种反模式，称为乱穿马路(Jaywalking)，乱穿马路也是避免过十字路口的一 种方式。

### 目标:存储多值属性

### 反模式:格式化的逗号分隔列表

### 解决方案:创建一张交叉表

- 当一张表有指向另外两张表的外键时，我们称这种表为一张交叉表（联合表、多对多表、映射表），它实现了两张表之间 的多对多关系。
- 每个值都应该存储在各自的行与列中。

## 2、单纯的树

### 在层级数据中，你可能需要查询与整个集合或其子集相关的特定对象

- 组织架构图
- 话题型讨论

### 目标:分层存储与查询

### 反模式:总是依赖父节点

- 邻接表

	- 最常见的简单解决方案是添加 parent_id 字段
	- 使用邻接表查询树

		- 无法完成树操作中最普通的一项:查询一个节点的所有后代。

	- 使用邻接表维护树

		- 从一棵树中删除一个节点会变得比较复杂

### 解决方案:使用其他树模型

- 路径枚举

	- 路径枚举是一个由连续的直接层级关系组成的完整路径。如/usr/local/lib 的 UNIX 路径 是文件系统的一个路径枚举，其中 usr 是 local 的父亲，这也就意味着 usr 是 lib 的祖先。

- 嵌套集

	- 存储子孙节点的相关信息，而不是节点的直接祖先。我们使用两个数字来编码每个节点，从而表示这一信息

- 闭包表

	- 闭包表是解决分级存储的一个简单而优雅的解决方案，它记录了树中所有节点间的关系，而不仅仅只有那些直接的父子关系。
	- 

## 3、需要 ID

### 目标:建立主键规范

### 反模式:以不变应万变

- 冗余键值
- 允许重复项
- 意义不明的关键字
- 使用USING关键字
- 使用组合键之难

### 解决方案:裁剪设计

- 直截了当地描述设计

	- 为主键选择更有意义的名称:一个能够反应这个主键所代表的实体的类型的名字。

- 打破传统
- 拥抱自然键和组合键

	- 如果你的表中包含一列能确保唯一、非空以及能够用来定位一条记录，就别仅仅因为传统而觉得有必要再加上一个伪主键。
	- 在合适的时候也可以使用组合键，比如一条记录可以通过多列的组合完全定位

## 4、不用钥匙的入口

### 目标:简化数据库架构

### 反模式:无视约束

- 假设无瑕代码
- 检查错误
- 那不是我的错
- 进退维谷

### 解决方案:声明约束

- 支持同步修改

	- 外键有另一个在应用程序中无法模拟的特性:级联更新。

- 系统开销过度?不见得

	- 外键约束需要多那么一点额外的系统开销，但相比于其他的一些选择，外键确实更高 效一点。

## 5、实体-属性-值

### 目标:支持可变的属性

### 反模式:使用泛型属性表

- 当需要支持可变属性时，第一反应便是创建另一张表，将属性当成行来存储。

	- 实体:通常来说这就是一个指向父表的外键，父表的每条记录表示一个实体对象。
	- 属性:在传统的表中，属性即每一列的名字，但在这个新的设计中，我们需要根据不同的记录来解析其标识的对象属性。
	- 值:对于每个实体的每一个不同属性，都有一个对应的值。

- 查询属性
- 支持数据完整性
- 无法声明强制属性
- 无法使用 SQL 的数据类型
- 无法确保引用完整性
- 无法配置属性名
- 重组列

### 解决方案:模型化子类型

- 单表继承
- 实体表继承
- 类表继承
- 半结构化数据模型
- 后处理

## 6、多态关联

### 目标:引用多个父表

### 反模式:使用双用途外键

- 定义多态关联
- 使用多态关联进行查询
- 非面向对象范例

### **解决方案:让关系变得简单**

- 反向引用
- 创建交叉表
- 设立交通灯
- 双向查找
- 合并跑道
- 创建共用的超级表

## 7、多列属性

### 目标:存储多值属性

### 反模式:创建多个列

- 查询数据
- 添加及删除值
- 确保唯一性
- 处理不断增长的值集

### 解决方案:创建从属表

## 8、元数据分裂

### 目标:支持可扩展性

### 反模式:克隆表与克隆列

- 不断产生的新表
- 管理数据完整性
- 同步数据
- 确保唯一性
- 跨表查询
- 同步元数据
- 管理引用完整性
- 标识元数据分裂列

### 解决方案:分区及标准化

- 使用水平分区
- 使用垂直分区
- 解决元数据分裂列

## 9、取整错误

### 目标:使用小数取代整数

### 反模式:使用 FLOAT 类型

- 舍入的必要性
- 在SQL中使用FLOAT

### 解决方案:使用 NUMERIC 类型

## 10、每日新花样

### 目标:限定列的有效值

### 反模式:在列定义上指定可选值

- 中间的是哪个
- 添加新口味
- 老的口味永不消失
- 可移植性低下

### 解决方案:在数据中指定值

- 查询候选值集合
- 更新检查表中的值
- 支持废弃数据
- 良好的可移植性

## 11、幽灵文件

### 目标:存储图片或其他多媒体大文件

### 反模式:假设你必须使用文件系统

- 文件不支持DELETE
- 文件不支持事务隔离
- 文件不支持回滚操作
- 文件不支持数据库备份工具
- 文件不支持SQL的访问权限设置
- 文件不是SQL数据类型

### 解决方案:在需要时使用 BLOB 类型

## 12、乱用索引

### 目标:优化性能

### 反模式:无规划地使用索引

- 无索引
- 索引过多
- 索引也无能为力

### 解决方案:MENTOR 你的索引

- 测量(Measure)

	- 记录执行 SQL 查询的时耗，因此可以以此来定位最耗时的查询。

- 解释(Explain)

	- 找出它之所以会这么慢的原因。

- 挑选(Nominate)

	- 查找那些没有使用索引的查询操作。

- 测试(Test)

	- 创建完索引之后，需要重新跟踪那些查询。需要确认你的改动确实提升了性能，然后就能确定工作完成了。

- 优化(Optimize)

	- 索引是小型的、频繁使用的数据结构，因而很适合将它们常驻在内存中。内存操作的性能是磁盘 I/O 操作的好几倍。

- 重建(Rebuild)

	- 索引在平衡的时候其效率最高，当你更新或者删除记录时，索引就逐渐变得不平衡，就如 同文件系统随着时间的推移会产生很多磁盘碎片一样。
	- 想要最大限度地使用索引，因此要定期对索引进 行维护。

## 13、对未知的恐惧

### 目标:辨别悬空值

### 反模式:将 NULL 作为普通的值，反之亦然

- 在表达式中使用NULL
- 搜索允许为空的列
- 在查询参数中使用NULL
- 避免上述问题
- 使用 NULL 并不是反模式，反模式是将 NULL 作为一个普通值处理或者使用一个普通的值来取代 NULL 的作用。

### 解决方案:将 NULL 视为特殊值

- 在标量表达式中使用NULL
- 在布尔表达式中使用NULL
- 检索NULL值
- 声明NOT NULL的列
- 动态默认值

## 14、模棱两可的分组

### 目标:获取每组的最大值

### 反模式:引用非分组列

- 单值规则

	- 跟在 SELECT 之后的选择列表中的每一列，对于每个分组来说都必须返回且仅返回一个值。

- 我想要的查询

### 解决方案:无歧义地使用列

- 只查询功能依赖的列
- 使用关联子查询
- 使用衍生表
- 使用JOIN
- 对额外的列使用聚合函数
- 连接同组所有值

## 15、随机选择

### 目标:获取样本记录

### 反模式:随机排序

### 解决方案:没有具体的顺序

- 从 1 到最大值之间随机选择
- 选择下一个最大值
- 获取所有的键值，随机选择一个
- 使用偏移量选择随机行
- 专有解决方案

## 16、可怜人的搜索引擎

### 目标:全文搜索

### 反模式:模式匹配断言

- 使用模式匹配操作符的最大缺点就在于性能问题。它们无法从传统的索引上受益，因此必须进行全表遍历

## 17、意大利面条式查询

### 目标: 减少 SQL 查询数量

### 反模式: 使用一步操作解决复杂问题

### 解决方案:分而治之

- 寻找 UNION 标记

## 18、隐式的列

### 目标: 减少输入

### 反模式: 捷径会让你迷失方向

- 破坏代码重构
- 隐藏的开销

	- 一次查询所获取的列越多，客户端程序和数据库之间的网络传输的字节数也越多。

### 解决方案: 明确列出列名

## 19、明文密码

### 目标：恢复或重置密码

### 反模式：使用明文存储密码

- 存储密码
- 验证密码
- 在 E-mail 中发送密码

### 解决方案：先哈希，后存储

- 理解哈希函数

	- 哈希是指将输入字符串转化成另一个新的、不可识 别的字符串的函数。
	- 哈希的另一个特征就是不可逆。

		- 哈希函数的算法设计就是要「丢失」一些输入串的信息， 所以你无法从一个哈希串恢复出原始输入串。

	- MD5 是另一个流行的哈希函数，产生 128 位的哈希串。

- 在 SQL 中使用哈希
- 给哈希加料

	- 将用户密码传入哈希函数进行加密之前，将其和一个无意义的串拼接在一起，即使用户选择了一个在字 典中存在的单词作为密码，对加料密码进行哈希得到的串是不太会出现在攻击者的哈希数据库中的，你可以发现增加了随机串得到的哈希值和原始值是不一样的

- 在 SQL 中隐藏密码
- 重置密码，而非恢复密码

## 20、SQL 注入

### 目标：编写 SQL 动态查询

### 反模式：将未经验证的输入作为代码执行

- 意外无处不在
- 对 Web 安全的严重威胁
- 寻找治愈良方

	- 转义
	- 查询参数
	- 存储过程
	- 数据访问框架

### 解决方案：不信任任何人

- 过滤输入内容
- 参数化动态内容
- 给动态输入的值加引号
- 将用户与代码隔离
- 找个可靠的人来帮你审查代码

## 21、伪键洁癖

### 目标：整理数据

### 反模式：填充角落

- 不按照顺序分配编号
- 为现有行重新编号
- 制造数据差异

### 解决方案：克服心里障碍

- 定义行号
- 使用 GUID

## 22、非礼勿视

### 目标：写更少的代码

### 反模式：无米之炊

- 没有诊断的诊断
- 字里行间

### 解决方案：优雅地从错误中恢复

- 保持节奏
- 回溯你的脚步

## 23、外交豁免权

### 目标：采用最佳实践

### 解决方案：建立一个质量至上的文化

- 陈列A：编写文档
- 寻找证据：源代码版本控制
- 举证：测试
- 例证：同时处理多个分支

## 24、魔豆

### 目标：简化 MVC 的模型

## 25、规范化规则

### 关系是什么

- 行之间没有上下顺序
- 列之间没有左右顺序
- 重复行是不允许的
- 每一列只有一种类型，每一行只有一个值
- 行没有隐藏组件

### 规范化的神话

- 规范化的目标

	- 以一种我们能够理解的方式表达这个世界中的事物;
	- 减少数据的冗余存储，防止异常或者不一致的数据;
	- 支持完整性约束。

- 第一范式

	- 第一范式的最根本要求是，该表必须是一个关系。

- 第二范式
- 第三范式
- 博伊斯—科德范式

	- 在第三范式中，所有的非关键字列都必须直接依赖于这张表中的关键字列，而在博伊斯—科 德范式中，所有关键字列也必须遵循这一规则，这一点在一张表有多种列的集合可作为表的关键 字时才有效。

- 第四范式
- 第五范式

	- 任何满足博伊斯—科德范式并且没有复合主键的表将同时满足第五范式。

- 更多的范式

	- DK范式(Domain-Keynormalform)认为表上的每个约束都是这张表的数据域约束和关键字约束的逻辑结果。DK 范式涵盖了第三、四、五范式和博伊斯—科德范式。

